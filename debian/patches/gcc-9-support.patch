This change adds support for parsing the output of gcov's intermediate
JSON file format as implemented by GCC version 9.

Note: The way that the intermediate file format support is implemented
in geninfo removes the need to parse .gcno files directly. Since geninfo
does not include support for parsing GCC 9 .gcno files, using the
intermediate format is the only option for geninfo to collect coverage
data generated by GCC version 9.

https://github.com/linux-test-project/lcov/commit/75fbae1cfc5027f818a0bb865bf6f96fab3202da?diff=unified
Signed-off-by: Peter Oberparleiter <oberpar@linux.ibm.com>


--- a/bin/geninfo
+++ b/bin/geninfo
@@ -305,9 +305,8 @@
 {
 	# Remove spaces around rc options
 	my %new_opt_rc;
-	my @keys = keys %opt_rc;
-	for my $key (@keys) {
-		my $value = $opt_rc{$key};
+
+	while (my ($key, $value) = each(%opt_rc)) {
 		$key =~ s/^\s+|\s+$//g;
 		$value =~ s/^\s+|\s+$//g;
 
@@ -1953,9 +1952,8 @@
 				$number = (split(" ",substr($_, 0, 16)))[0];
 
 				# Check for zero count which is indicated
-				# by ###### or =====
-				if ($number eq "######" or
-				    $number eq "=====") { $number = 0; }
+				# by ######
+				if ($number eq "######") { $number = 0;	}
 
 				if ($exclude_line) {
 					# Register uninstrumented line instead
@@ -2018,9 +2016,6 @@
 				# Skip instance-specific counts
 				next if ($line <= (scalar(@result) / 3));
 
-				# Skip instance-specific counts
-				next if ($line == $last_line);
-
 				$last_line = $line;
 				$last_block = $UNNAMED_BLOCK;
 				# Check for exclusion markers
@@ -2066,10 +2061,6 @@
 				# Strip unexecuted basic block marker
 				$count =~ s/\*$//;
 
-				 
-				# Strip unexecuted basic block marker
-				$count =~ s/\*$//;
-				
 				# <exec count>:<line number>:<source code>
 				if ($line eq "0")
 				{
@@ -2428,6 +2419,453 @@
 		print($fd "end_of_record\n");
 	}
 }
+
+
+sub get_output_fd($$)
+{
+	my ($outfile, $file) = @_;
+	my $fd;
+
+	if (!defined($outfile)) {
+		open($fd, ">", "$file.info") or
+			die("ERROR: Cannot create file $file.info: $!\n");
+	} elsif ($outfile eq "-") {
+		open($fd, ">&STDOUT") or
+			die("ERROR: Cannot duplicate stdout: $!\n");
+	} else {
+		open($fd, ">>", $outfile) or
+			die("ERROR: Cannot write to file $outfile: $!\n");
+	}
+
+	return $fd;
+}
+
+
+#
+# print_gcov_warnings(stderr_file, is_graph, map)
+#
+# Print GCOV warnings in file STDERR_FILE to STDERR. If IS_GRAPH is non-zero,
+# suppress warnings about missing as these are expected. Replace keys found
+# in MAP with their values.
+#
+
+sub print_gcov_warnings($$$)
+{
+	my ($stderr_file, $is_graph, $map) = @_;
+	my $fd;
+
+	if (!open($fd, "<", $stderr_file)) {
+		warn("WARNING: Could not open GCOV stderr file ".
+		     "$stderr_file: $!\n");
+		return;
+	}
+	while (my $line = <$fd>) {
+		next if ($is_graph && $line =~ /cannot open data file/);
+
+		for my $key (keys(%{$map})) {
+			$line =~ s/\Q$key\E/$map->{$key}/g;
+		}
+
+		print(STDERR $line);
+	}
+	close($fd);
+}
+
+
+#
+# process_intermediate(file, dir, tempdir)
+#
+# Create output for a single file (either a data file or a graph file) using
+# gcov's intermediate option.
+#
+
+sub process_intermediate($$$)
+{
+	my ($file, $dir, $tempdir) = @_;
+	my ($fdir, $fbase, $fext);
+	my $data_file;
+	my $errmsg;
+	my %data;
+	my $fd;
+	my $base;
+	my $srcdata;
+	my $is_graph = 0;
+	my ($out, $err, $rc);
+	my $json_basedir;
+	my $json_format;
+
+	info("Processing %s\n", abs2rel($file, $dir));
+
+	$file = solve_relative_path($cwd, $file);
+	($fdir, $fbase, $fext) = split_filename($file);
+
+	$is_graph = 1 if (".$fext" eq $graph_file_extension);
+
+	if ($is_graph) {
+		# Process graph file - copy to temp directory to prevent
+		# accidental processing of associated data file
+		$data_file = "$tempdir/$fbase$graph_file_extension";
+		if (!copy($file, $data_file)) {
+			$errmsg = "ERROR: Could not copy file $file";
+			goto err;
+		}
+	} else {
+		# Process data file in place
+		$data_file = $file;
+	}
+
+	# Change directory
+	if (!chdir($tempdir)) {
+		$errmsg = "Could not change to directory $tempdir: $!";
+		goto err;
+	}
+
+	# Run gcov on data file
+	($out, $err, $rc) = system_no_output(1 + 2 + 4, $gcov_tool,
+					     $data_file, @gcov_options, "-i");
+	defined($out) && unlink($out);
+	if (defined($err)) {
+		print_gcov_warnings($err, $is_graph, {
+			$data_file => $file,
+		});
+		unlink($err);
+	}
+	if ($rc) {
+		$errmsg = "GCOV failed for $file";
+		goto err;
+	}
+
+	if ($is_graph) {
+		# Remove graph file copy
+		unlink($data_file);
+	}
+
+	# Parse resulting file(s)
+	for my $gcov_filename (glob("*.gcov")) {
+		read_intermediate_text($gcov_filename, \%data);
+		unlink($gcov_filename);
+	}
+
+	for my $gcov_filename (glob("*.gcov.json.gz")) {
+		read_intermediate_json($gcov_filename, \%data, \$json_basedir);
+		unlink($gcov_filename);
+		$json_format = 1;
+	}
+
+	if (!%data) {
+		warn("WARNING: GCOV did not produce any data for $file\n");
+		return;
+	}
+
+	# Determine base directory
+	if (defined($base_directory)) {
+		$base = $base_directory;
+	} elsif (defined($json_basedir)) {
+		$base = $json_basedir;
+	} else {
+		$base = $fdir;
+
+		if (is_compat($COMPAT_MODE_LIBTOOL)) {
+			# Avoid files from .libs dirs
+			$base =~ s/\.libs$//;
+		}
+
+		# Try to find base directory automatically if requested by user
+		if ($rc_auto_base) {
+			$base = find_base_from_source($base, [ keys(%data) ]);
+		}
+	}
+
+	# Apply base file name to relative source files
+	adjust_source_filenames(\%data, $base);
+
+	# Remove excluded source files
+	filter_source_files(\%data);
+
+	# Get data on exclusion markers and checksums if requested
+	if (!$no_markers || $checksum) {
+		$srcdata = get_all_source_data(keys(%data));
+	}
+
+	# Generate output
+	$fd = get_output_fd($output_filename, $file);
+	if ($json_format) {
+		intermediate_json_to_info($fd, \%data, $srcdata);
+	} else {
+		intermediate_text_to_info($fd, \%data, $srcdata);
+	}
+	close($fd);
+
+	chdir($cwd);
+
+	return;
+
+err:
+	if ($ignore[$ERROR_GCOV]) {
+		warn("WARNING: $errmsg!\n");
+	} else {
+		die("ERROR: $errmsg!\n")
+	}
+}
+
+
+#
+# read_intermediate_text(gcov_filename, data)
+#
+# Read gcov intermediate text format in GCOV_FILENAME and add the resulting
+# data to DATA in the following format:
+#
+# data:      source_filename -> file_data
+# file_data: concatenated lines of intermediate text data
+#
+
+sub read_intermediate_text($$)
+{
+	my ($gcov_filename, $data) = @_;
+	my $fd;
+	my $filename;
+
+	open($fd, "<", $gcov_filename) or
+		die("ERROR: Could not read $gcov_filename: $!\n");
+	while (my $line = <$fd>) {
+		if ($line =~ /^file:(.*)$/) {
+			$filename = $1;
+			chomp($filename);
+		} elsif (defined($filename)) {
+			$data->{$filename} .= $line;
+		}
+	}
+	close($fd);
+}
+
+
+#
+# read_intermediate_json(gcov_filename, data, basedir_ref)
+#
+# Read gcov intermediate JSON format in GCOV_FILENAME and add the resulting
+# data to DATA in the following format:
+#
+# data:      source_filename -> file_data
+# file_data: GCOV JSON data for file
+#
+# Also store the value for current_working_directory to BASEDIR_REF.
+#
+
+sub read_intermediate_json($$$)
+{
+	my ($gcov_filename, $data, $basedir_ref) = @_;
+	my $fd;
+	my $text;
+	my $json;
+
+	open($fd, "<:gzip", $gcov_filename) or
+		die("ERROR: Could not read $gcov_filename: $!\n");
+	local $/;
+	$text = <$fd>;
+	close($fd);
+
+	$json = decode_json($text);
+	if (!defined($json) || !exists($json->{"files"}) ||
+	    ref($json->{"files"} ne "ARRAY")) {
+		die("ERROR: Unrecognized JSON output format in ".
+		    "$gcov_filename\n");
+	}
+
+	$$basedir_ref = $json->{"current_working_directory"};
+
+	for my $file (@{$json->{"files"}}) {
+		my $filename = $file->{"file"};
+
+		$data->{$filename} = $file;
+	}
+}
+
+
+#
+# intermediate_text_to_info(fd, data, srcdata)
+#
+# Write DATA in info format to file descriptor FD.
+#
+# data:      filename -> file_data:
+# file_data: concatenated lines of intermediate text data
+#
+# srcdata:   filename -> [ excl, brexcl, checksums ]
+# excl:      lineno -> 1 for all lines for which to exclude all data
+# brexcl:    lineno -> 1 for all lines for which to exclude branch data
+# checksums: lineno -> source code checksum
+#
+# Note: To simplify processing, gcov data is not combined here, that is counts
+#       that appear multiple times for the same lines/branches are not added.
+#       This is done by lcov/genhtml when reading the data files.
+#
+
+sub intermediate_text_to_info($$$)
+{
+	my ($fd, $data, $srcdata) = @_;
+	my $branch_num = 0;
+	my $c;
+
+	return if (!%{$data});
+
+	print($fd "TN:$test_name\n");
+	for my $filename (keys(%{$data})) {
+		my ($excl, $brexcl, $checksums);
+
+		if (defined($srcdata->{$filename})) {
+			($excl, $brexcl, $checksums) = @{$srcdata->{$filename}};
+		}
+
+		print($fd "SF:$filename\n");
+		for my $line (split(/\n/, $data->{$filename})) {
+			if ($line =~ /^lcount:(\d+),(\d+),?/) {
+				# lcount:<line>,<count>
+				# lcount:<line>,<count>,<has_unexecuted_blocks>
+				if ($checksum && exists($checksums->{$1})) {
+					$c = ",".$checksums->{$1};
+				} else {
+					$c = "";
+				}
+				print($fd "DA:$1,$2$c\n") if (!$excl->{$1});
+
+				# Intermediate text format does not provide
+				# branch numbers, and the same branch may appear
+				# multiple times on the same line (e.g. in
+				# template instances). Synthesize a branch
+				# number based on the assumptions:
+				# a) the order of branches is fixed across
+				#    instances
+				# b) an instance starts with an lcount line
+				$branch_num = 0;
+			} elsif ($line =~ /^function:(\d+),(\d+),([^,]+)$/) {
+				next if (!$func_coverage || $excl->{$1});
+
+				# function:<line>,<count>,<name>
+				print($fd "FN:$1,$3\n");
+				print($fd "FNDA:$2,$3\n");
+			} elsif ($line =~ /^function:(\d+),\d+,(\d+),([^,]+)$/) {
+				next if (!$func_coverage || $excl->{$1});
+
+				# function:<start_line>,<end_line>,<count>,
+				#          <name>
+				print($fd "FN:$1,$3\n");
+				print($fd "FNDA:$2,$3\n");
+			} elsif ($line =~ /^branch:(\d+),(taken|nottaken|notexec)/) {
+				next if (!$br_coverage || $excl->{$1} ||
+					 $brexcl->{$1});
+
+				# branch:<line>,taken|nottaken|notexec
+				if ($2 eq "taken") {
+					$c = 1;
+				} elsif ($2 eq "nottaken") {
+					$c = 0;
+				} else {
+					$c = "-";
+				}
+				print($fd "BRDA:$1,0,$branch_num,$c\n");
+				$branch_num++;
+			}
+		}
+		print($fd "end_of_record\n");
+	}
+}
+
+
+#
+# intermediate_json_to_info(fd, data, srcdata)
+#
+# Write DATA in info format to file descriptor FD.
+#
+# data:      filename -> file_data:
+# file_data: GCOV JSON data for file
+#
+# srcdata:   filename -> [ excl, brexcl, checksums ]
+# excl:      lineno -> 1 for all lines for which to exclude all data
+# brexcl:    lineno -> 1 for all lines for which to exclude branch data
+# checksums: lineno -> source code checksum
+#
+# Note: To simplify processing, gcov data is not combined here, that is counts
+#       that appear multiple times for the same lines/branches are not added.
+#       This is done by lcov/genhtml when reading the data files.
+#
+
+sub intermediate_json_to_info($$$)
+{
+	my ($fd, $data, $srcdata) = @_;
+	my $branch_num = 0;
+
+	return if (!%{$data});
+
+	print($fd "TN:$test_name\n");
+	for my $filename (keys(%{$data})) {
+		my ($excl, $brexcl, $checksums);
+		my $file_data = $data->{$filename};
+
+		if (defined($srcdata->{$filename})) {
+			($excl, $brexcl, $checksums) = @{$srcdata->{$filename}};
+		}
+
+		print($fd "SF:$filename\n");
+
+		# Function data
+		if ($func_coverage) {
+			for my $d (@{$file_data->{"functions"}}) {
+				my $line = $d->{"start_line"};
+				my $count = $d->{"execution_count"};
+				my $name = $d->{"name"};
+
+				next if (!defined($line) || !defined($count) ||
+					 !defined($name) || $excl->{$line});
+
+				print($fd "FN:$line,$name\n");
+				print($fd "FNDA:$count,$name\n");
+			}
+		}
+
+		# Line data
+		for my $d (@{$file_data->{"lines"}}) {
+			my $line = $d->{"line_number"};
+			my $count = $d->{"count"};
+			my $c;
+			my $branches = $d->{"branches"};
+			my $unexec = $d->{"unexecuted_block"};
+
+			next if (!defined($line) || !defined($count) ||
+				 $excl->{$line});
+
+			if (defined($unexec) && $unexec && $count == 0) {
+				$unexec = 1;
+			} else {
+				$unexec = 0;
+			}
+
+			if ($checksum && exists($checksums->{$line})) {
+				$c = ",".$checksums->{$line};
+			} else {
+				$c = "";
+			}
+			print($fd "DA:$line,$count$c\n");
+
+			$branch_num = 0;
+			# Branch data
+			if ($br_coverage && !$brexcl->{$line}) {
+				for my $b (@$branches) {
+					my $brcount = $b->{"count"};
+
+					if (!defined($brcount) || $unexec) {
+						$brcount = "-";
+					}
+					print($fd "BRDA:$line,0,$branch_num,".
+					      "$brcount\n");
+
+					$branch_num++;
+				}
+			}
+
+		}
+
+		print($fd "end_of_record\n");
+	}
+}
 
 
 sub get_output_fd($$)
