<?xml version="1.0" encoding="UTF-8" ?>
<!-- Data taken from descriptions.tests in lcov package
     and formatted as XML
     Alastair McKinstry <mckinstry@debian.org>
  -->
<test name="personality01">
  <description>
  Check that we can set the personality for a process.
  </description>
</test>
<test name="personality02">
  <description>
  Check that we get EINVAL for a bad personality.
<test name="exit01">
  <description>
  Check that exit returns the correct values to the waiting parent
<test name="exit02">
  <description>
  Check that exit flushes output file buffers and closes files upon
  exiting
<test name="wait02">
  <description>
  Basic test for wait(2) system call. 
<test name="wait401">
  <description>
  check that a call to wait4() correctly waits for a child
  process to exit
  </description>
</test>
<test name="wait402">
  <description>
  check for ECHILD errno when using an illegal pid value
  </description>
</test>
<test name="waitpid01">
  <description>
  Check that when a child kills itself by generating an alarm
  exception, the waiting parent is correctly notified.
  </description>
</test>
<test name="waitpid02">
  <description>
  Check that when a child kills itself by generating an integer zero
  divide exception, the waiting parent is correctly notified.
  </description>
</test>
<test name="waitpid03">
  <description>
  Check that parent waits until specific child has returned.
  </description>
</test>
<test name="waitpid04">
  <description>
  test to check the error conditions in waitpid sys call
  </description>
</test>
<test name="waitpid05">
  <description>
  Check that when a child kills itself with a kill statement after
  determining its process id by using getpid, the parent receives a
  correct report of the cause of its death. This also indirectly
  checks that getpid returns the correct process id.
  </description>
</test>
<test name="waitpid06">
  <description>
  Tests to see if pid's returned from fork and waitpid are same.
  </description>
</test>
<test name="waitpid07">
  <description>
  Tests to see if pid's returned from fork and waitpid are same.
  </description>
</test>
<test name="waitpid08">
  <description>
  Tests to see if pid's returned from fork and waitpid are same
  </description>
</test>
<test name="waitpid09">
  <description>
  Check ability of parent to wait until child returns, and that the
  child's process id is returned through the waitpid. Check that
  waitpid returns immediately if no child is present.
  </description>
</test>
<test name="waitpid10">
  <description>
  Tests to see if pid's returned from fork and waitpid are same
  </description>
</test>
<test name="waitpid11">
  <description>
  Tests to see if pid's returned from fork and waitpid are same
  </description>
</test>
<test name="waitpid12">
  <description>
  Tests to see if pid's returned from fork and waitpid are same
  </description>
</test>
<test name="waitpid13">
  <description>
  Tests to see if pid's returned from fork and waitpid are same
  </description>
</test>
<test name="fcntl01">
  <description>
  Test F_DUPFD, F_SETFL cmds of fcntl
  </description>
</test>
<test name="fcntl02">
  <description>
  Basic test for fcntl(2) using F_DUPFD argument.
  </description>
</test>
<test name="fcntl03">
  <description>
  Basic test for fcntl(2) using F_GETFD argument.
  </description>
</test>
<test name="fcntl04">
  <description>
  Basic test for fcntl(2) using F_GETFL argument. 
  </description>
</test>
<test name="fcntl05">
  <description>
  Basic test for fcntl(2) using F_GETLK argument. 
  </description>
</test>
<test name="fcntl06">
  <description>
  Error checking conditions for remote locking of regions of a file.
  </description>
</test>
<test name="fcntl07">
  <description>
  Close-On-Exec functional test. 
  </description>
</test>
<test name="fcntl07B">
  <description>
  Close-On-Exec of named pipe functional test. 
  </description>
</test>
<test name="fcntl08">
  <description>
  Basic test for fcntl(2) using F_SETFL argument. 
  </description>
</test>
<test name="fcntl09">
  <description>
  Basic test for fcntl(2) using F_SETLK argument. 
  </description>
</test>
<test name="fcntl10">
  <description>
  Basic test for fcntl(2) using F_SETLKW argument. 
  </description>
</test>
<test name="fcntl11">
  <description>
  Testcase to check locking of regions of a file
  </description>
</test>
<test name="fcntl12">
  <description>
  Testcase to test that fcntl() sets EMFILE for F_DUPFD command.
  </description>
</test>
<test name="fcntl13">
  <description>
  Testcase to test that fcntl() sets errno correctly.
  </description>
</test>
<test name="fcntl14">
  <description>
  File locking test cases for fcntl. In Linux, S_ENFMT is not implemented
  in the kernel. However all standard Unix kernels define S_ENFMT as
  S_ISGID. So this test defines S_ENFMT as S_ISGID.
  </description>
</test>
<test name="fcntl15">
  <description>
  Check that file locks are removed when file closed
  </description>
</test>
<test name="fcntl16">
  <description>
  Additional file locking test cases for checking proper notification
  of processes on lock change
  </description>
</test>
<test name="fcntl17">
  <description>
  Check deadlock detection for file locking
  </description>
</test>
<test name="fcntl18">
  <description>
  Test to check the error conditions in fcntl system call
  </description>
</test>
<test name="fcntl19">
  <description>
  Testcase to check locking of regions of a file
  </description>
</test>
<test name="fcntl20">
  <description>
  Check locking of regions of a file
  </description>
</test>
<test name="fcntl21">
  <description>
  Check locking of regions of a file
  </description>
</test>
<test name="dup01">
  <description>
  Basic test for dup(2).
  </description>
</test>
<test name="dup02">
  <description>
  Negative test for dup(2) with bad fd.
  </description>
</test>
<test name="dup03">
  <description>
  Negative test for dup(2) (too many fds).
  </description>
</test>
<test name="dup04">
  <description>
  Basic test for dup(2) of a system pipe descriptor.
  </description>
</test>
<test name="dup05">
  <description>
  Basic test for dup(2) of a named pipe descriptor. 
  </description>
</test>
<test name="dup201">
  <description>
  Negative tests for dup2() with bad fd (EBADF), and for "too many
  open files" (EMFILE)
  </description>
</test>
<test name="dup202">
  <description>
  Is the access mode the same for both file descriptors?
  0: read only ?	"0444"
  1: write only ? "0222"
  2: read/write ? "0666"
  </description>
</test>
<test name="dup203">
  <description>
  Testcase to check the basic functionality of dup2().
  </description>
</test>
<test name="dup204">
  <description>
  Testcase to check the basic functionality of dup2(2).
  </description>
</test>
<test name="msync01">
  <description>
  Verify that, msync() succeeds, when the region to synchronize, is part
  of, or all of a mapped region.
  </description>
</test>
<test name="msync02">
  <description>
  Verify that msync() succeeds when the region to synchronize is mapped
  shared and the flags argument is MS_INVALIDATE.
  </description>
</test>
<test name="msync03">
  <description>
  Verify that, msync() fails, when the region to synchronize, is outside
  the address space of the process.
  </description>
</test>
<test name="msync04">
  <description>
  Verify that, msync() fails, when the region to synchronize, is mapped
  but the flags argument is invalid.
  </description>
</test>
<test name="msync05">
  <description>
  Verify that, msync() fails, when the region to synchronize, was not
  mapped.
  </description>
</test>
<test name="sendfile02">
  <description>
  Testcase to test the basic functionality of the sendfile(2) system call.
  </description>
</test>
<test name="sendfile03">
  <description>
  Testcase to test that sendfile(2) system call returns appropriate
  errnos on error.
  </description>
</test>
<test name="fork01">
  <description>
  Basic test for fork(2). 
  </description>
</test>
<test name="fork02">
  <description>
  Test correct operation of fork:
  pid == 0 in child;
  pid > 0 in parent from wait;
  </description>
</test>
<test name="fork03">
  <description>
  Check that child can use a large text space and do a large
  number of operations.	
  </description>
</test>
<test name="fork04">
  <description>
  Child inheritance of Environment Variables after fork(). 
  </description>
</test>
<test name="fork05">
  <description>
  Make sure LDT is propagated correctly 
  </description>
</test>
<test name="fork06">
  <description>
  Test that a process can fork children a large number of
  times in succession
  </description>
</test>
<test name="fork07">
  <description>
  Check that all children inherit parent's file descriptor
  </description>
</test>
<test name="fork08">
  <description>
  Check if the parent's file descriptors are affected by 
  actions in the child; they should not be.
  </description>
</test>
<test name="fork09">
  <description>
  Check that child has access to a full set of files.
  </description>
</test>
<test name="fork10">
  <description>
  Check inheritance of file descriptor by children, they
  should all be referring to the same file.
  </description>
</test>
<test name="fork11">
  <description>
  Test that parent gets a pid from each child when doing wait
  </description>
</test>
<test name="vfork01">
  <description>
  Fork a process using vfork() and verify that, the attribute values like
  euid, ruid, suid, egid, rgid, sgid, umask, inode and device number of
  root and current working directories are same as that of the parent 
  process.
  </description>
</test>
<test name="vfork02">
  <description>
  Fork a process using vfork() and verify that, the pending signals in
  the parent are not pending in the child process.
  </description>
</test>
<test name="ioctl01">
  <description>
  Testcase to check the errnos set by the ioctl(2) system call.
  </description>
</test>
<test name="ioctl02">
  <description>
  Testcase to test the TCGETA, and TCSETA ioctl implementations for
  the tty driver
  </description>
</test>
<test name="sockioctl01">
  <description>
  Verify that ioctl() on sockets returns the proper errno for various
  failure cases
  </description>
</test>
<test name="getitimer01">
  <description>
  check that a correct call to getitimer() succeeds
  </description>
</test>
<test name="getitimer02">
  <description>
  check that a getitimer() call fails as expected
  with an incorrect second argument.
  </description>
</test>
<test name="getitimer03">
  <description>
  check that a getitimer() call fails as expected
  with an incorrect first argument.
  </description>
</test>
<test name="setitimer01">
  <description>
  check that a reasonable setitimer() call succeeds.
  </description>
</test>
<test name="setitimer02">
  <description>
  check that a setitimer() call fails as expected
  with incorrect values.
  </description>
</test>
<test name="setitimer03">
  <description>
  check that a setitimer() call fails as expected
  with incorrect values.
  </description>
</test>
<test name="float_trigo">
  <description>
  increase CPUs workload - verify that results of some math functions are stable
  trigonometric (acos, asin, atan, atan2, cos, sin, tan),
  hyperbolic (cosh, sinh, tanh),
  </description>
</test>
<test name="float_exp_log">
  <description>
  increase CPUs workload - verify that results of some math functions are stable
  exponential and logarithmic functions (exp, log, log10),
  Functions that manipulate floating-point numbers (modf, ldexp, frexp),
  Euclidean distance function (hypot),
  </description>
</test>
<test name="float_bessel">
  <description>
  increase CPUs workload - verify that results of some math functions are stable
  Bessel (j0, j1, y0, y1),
  Computes the natural logarithm of the gamma function (lgamma),
  </description>
</test>
<test name="fload_power">
  <description>
  increase CPUs workload - verify that results of some math functions are stable
  Computes sqrt, power, fmod
  </description>
</test>
<test name="float_iperb">
  <description>
  increase CPUs workload - verify that results of some math functions are stable
  </description>
</test>
<test name="pth_str01">
  <description>
  Creates a tree of threads
  </description>
</test>
<test name="pth_str02">
  <description>
  Creates n threads
  </description>
</test>
<test name="pth_str03">
  <description>
  Creates a tree of threads does calculations, and
  returns result to parent
  </description>
</test>
<test name="asyncio02">
  <description>
  Write/close flushes data to the file.
  </description>
</test>
<test name="fpathconf">
  <description>
  Basic test for fpathconf(2)
  </description>
</test>
<test name="gethostid01">
  <description>
  Basic test for gethostid(2) 
  </description>
</test>
<test name="pathconf01">
  <description>
  Basic test for pathconf(2) 
  </description>
</test>
<test name="setpgrp01">
  <description>
  Basic test for the setpgrp(2) system call.  
  </description>
</test>
<test name="setpgrp02">
  <description>
  Testcase to check the basic functionality of the setpgrp(2) syscall.
  </description>
</test>
<test name="ulimit01">
  <description>
  Basic test for the ulimit(2) system call. 
  </description>
</test>
<test name="mmstress">
  <description>
  Performs General Stress with Race conditions
  </description>
</test>
<test name="mmap1">
  <description>
  Test the LINUX memory manager. The program is aimed at
  stressing the memory manager by simultaneous map/unmap/read
  by light weight processes, the test is scheduled to run for
  a minimum of 24 hours.
  </description>
</test>
<test name="mmap2">
  <description>
  Test the LINUX memory manager. The program is aimed at
  stressing the memory manager by repeated map/write/unmap of a
  of a large gb size file.
  </description>
</test>
<test name="mmap3">
  <description>
  Test the LINUX memory manager. The program is aimed at
  stressing the memory manager by repeated map/write/unmap
  of file/memory of random size (maximum 1GB) this is done by
  multiple processes.
  </description>
</test>
<test name="mmap001">
  <description>
  Tests mmapping a big file and writing it once 
  </description>
</test>
<test name="mmap01">
  <description>
  Verify that, mmap() succeeds when used to map a file where size of the
  file is not a multiple of the page size, the memory area beyond the end
  of the file to the end of the page is accessible. Also, verify that
  this area is all zeroed and the modifications done to this area are
  not written to the file.
  </description>
</test>
<test name="mmap02">
  <description>
  Call mmap() with prot parameter set to PROT_READ and with the file
  descriptor being open for read, to  map a file creating mapped memory
  with read access. The minimum file permissions should be 0444.
  </description>
</test>
<test name="mmap03">
  <description>
  Call mmap() to map a file creating a mapped region with execute access
  under the following conditions -
  - The prot parameter is set to PROT_EXE
  - The file descriptor is open for read
  - The file being mapped has execute permission bit set.
  - The minimum file permissions should be 0555.
  
  The call should succeed to map the file creating mapped memory with the
  required attributes.
  </description>
</test>
<test name="mmap04">
  <description>
  Call mmap() to map a file creating a mapped region with read/exec access
  under the following conditions -
  - The prot parameter is set to PROT_READ|PROT_EXEC
  - The file descriptor is open for read
  - The file being mapped has read and execute permission bit set.
  - The minimum file permissions should be 0555.

  The call should succeed to map the file creating mapped memory with the
  required attributes.
  </description>
</test>
<test name="mmap05">
  <description>
  Call mmap() to map a file creating mapped memory with no access under
  the following conditions -
  - The prot parameter is set to PROT_NONE
  - The file descriptor is open for read(any mode other than write)
  - The minimum file permissions should be 0444.

  The call should succeed to map the file creating mapped memory with the
  required attributes.
  </description>
</test>
<test name="mmap06">
  <description>
  Call mmap() to map a file creating a mapped region with read access
  under the following conditions -
  - The prot parameter is set to PROT_READ
  - The file descriptor is open for writing.

  The call should fail to map the file.
  </description>
</test>
<test name="mmap07">
  <description>
  Call mmap() to map a file creating a mapped region with read access
  under the following conditions -
  - The prot parameter is set to PROT_WRITE
  - The file descriptor is open for writing.
  - The flags parameter has MAP_PRIVATE set.

  The call should fail to map the file.
  </description>
</test>
<test name="mmap08">
  <description>
  Verify that mmap() fails to map a file creating a mapped region 
  when the file specified by file descriptor is not valid.
  </description>
</test>
<test name="mremap01">
  <description>
  Verify that, mremap() succeeds when used to expand the existing
  virtual memory mapped region to the requested size where the
  virtual memory area was previously mapped to a file using mmap().
  </description>
</test>
<test name="mremap02">
  <description>
  Verify that, 
  mremap() fails when used to expand the existing virtual memory mapped 
  region to the requested size, if the virtual memory area previously 
  mapped was not page aligned or invalid argument specified.
  </description>
</test>
<test name="mremap03">
  <description>
  Verify that, 
  mremap() fails when used to expand the existing virtual memory mapped 
  region to the requested size, if there already exists mappings that
  cover the whole address space requested or the old address specified was
  not mapped.
  </description>
</test>
<test name="mremap04">
  <description>
  Verify that, 
  mremap() fails when used to expand the existing virtual memory mapped 
  region to the requested size, if the memory area cannot be expanded at
  the current virtual address and MREMAP_MAYMOVE flag not set.
  </description>
</test>
<test name="munmap01">
  <description>
  Verify that, munmap call will succeed to unmap a mapped file or
  anonymous shared memory region from the calling process's address space
  and after successful completion of munmap, the unmapped region is no
  longer accessible.
  </description>
</test>
<test name="munmap02">
  <description>
  Verify that, munmap call will succeed to unmap a mapped file or
  anonymous shared memory region from the calling process's address space
  if the region specified by the address and the length is part or all of
  the mapped region.
  </description>
</test>
<test name="munmap03">
  <description>
  Verify that, munmap call will fail to unmap a mapped file or anonymous
  shared memory region from the calling process's address space if the
  address and the length of the region to be unmapped points outside the
  calling process's address space
  </description>
</test>
<test name="brk01">
  <description>
  Test the basic functionality of brk.
  </description>
</test>
<test name="sbrk01">
  <description>
  Basic test for the sbrk(2) system call.
  </description>
</test>
<test name="mprotect01">
  <description>
  Testcase to check the error conditions for mprotect(2)
  </description>
</test>
<test name="mprotect02">
  <description>
  Testcase to check the mprotect(2) system call.
  </description>
</test>
<test name="mprotect03">
  <description>
  Testcase to check the mprotect(2) system call.
  </description>
</test>
<test name="msgctl01">
  <description>
  create a message queue, then issue the IPC_STAT command
  and RMID commands to test the functionality
  </description>
</test>
<test name="msgctl02">
  <description>
  create a message queue, then issue the IPC_SET command
  to lower the msg_qbytes value.
  </description>
</test>
<test name="msgctl03">
  <description>
  create a message queue, then issue the IPC_RMID command
  </description>
</test>
<test name="msgctl04">
  <description>
  test for EACCES, EFAULT and EINVAL errors using
  a variety of incorrect calls.
  </description>
</test>
<test name="msgctl05">
  <description>
  test for EPERM error
  </description>
</test>
<test name="msgget01">
  <description>
  create a message queue, write a message to it and
  read it back.
  </description>
</test>
<test name="msgget02">
  <description>
  test for EEXIST and ENOENT errors
  </description>
</test>
<test name="msgget03">
  <description>
  test for an ENOSPC error by using up all available
  message queues.
  </description>
</test>
<test name="msgget04">
  <description>
  test for an EACCES error by creating a message queue
  with no read or write permission and then attempting
  to access it with various permissions.
  </description>
</test>
<test name="msgrcv01">
  <description>
  test that msgrcv() receives the expected message
  </description>
</test>
<test name="msgrcv02">
  <description>
  test for EACCES and EFAULT errors
  </description>
</test>
<test name="msgrcv03">
  <description>
  test for EINVAL error
  </description>
</test>
<test name="msgrcv04">
  <description>
  test for E2BIG and ENOMSG errors
  </description>
</test>
<test name="msgrcv05">
  <description>
  test for EINTR error
  </description>
</test>
<test name="msgrcv06">
  <description>
  test for EIDRM error
  </description>
</test>
<test name="msgsnd01">
  <description>
  test that msgsnd() enqueues a message correctly
  </description>
</test>
<test name="msgsnd02">
  <description>
  test for EACCES and EFAULT errors
  </description>
</test>
<test name="msgsnd03">
  <description>
  test for EINVAL error
  </description>
</test>
<test name="msgsnd04">
  <description>
  test for EAGAIN error
  </description>
</test>
<test name="msgsnd05">
  <description>
  test for EINTR error
  </description>
</test>
<test name="msgsnd06">
  <description>
  test for EIDRM error
  </description>
</test>
<test name="link02">
  <description>
  Basic test for link(2) 
  </description>
</test>
<test name="link03">
  <description>
  Multi links tests
  </description>
</test>
<test name="link04">
  <description>
  Negative test cases for link(2)
  </description>
</test>
<test name="link05">
  <description>
  Multi links (EMLINK) negative test 
  </description>
</test>
<test name="readlink01">
  <description>
  Verify that, readlink will succeed to read the contents of the symbolic
  link created the process.
  </description>
</test>
<test name="readlink02">
  <description>
  Basic test for the readlink(2) system call 
  </description>
</test>
<test name="readlink03">
  <description>
  Verify that,
  1) readlink(2) returns -1 and sets errno to EACCES if search/write
  permission is denied in the directory where the symbolic link
  resides.
  2) readlink(2) returns -1 and sets errno to EINVAL if the buffer size
  is not positive.
  3) readlink(2) returns -1 and sets errno to EINVAL if the specified
  file is not a symbolic link file.
  4) readlink(2) returns -1 and sets errno to ENAMETOOLONG if the 
  pathname component of symbolic link is too long (ie, > PATH_MAX).
  5) readlink(2) returns -1 and sets errno to ENOENT if the component of
  symbolic link points to an empty string.
  </description>
</test>
<test name="readlink04">
  <description>
  Verify that, readlink call will succeed to read the contents of the
  symbolic link if invoked by non-root user who is not the owner of the
  symbolic link.
  </description>
</test>
<test name="symlink01">
  <description>
  Test of various file function calls, such as rename or open, on a symbolic 
  link file. 
  </description>
</test>
<test name="symlink02">
  <description>
  Basic test for the symlink(2) system call. 
  </description>
</test>
<test name="symlink03">
  <description>
  Verify that,
  1) symlink(2) returns -1 and sets errno to EACCES if search/write
  permission is denied in the directory where the symbolic link is
  being created.
  2) symlink(2) returns -1 and sets errno to EEXIST if the specified 
  symbolic link already exists.
  3) symlink(2) returns -1 and sets errno to EFAULT if the specified
  file or symbolic link points to invalid address.
  4) symlink(2) returns -1 and sets errno to ENAMETOOLONG if the 
  pathname component of symbolic link is too long (ie, > PATH_MAX).
  5) symlink(2) returns -1 and sets errno to ENOTDIR if the directory
  component in pathname of symbolic link is not a directory.
  6) symlink(2) returns -1 and sets errno to ENOENT if the component of
  symbolic link points to an empty string.
  </description>
</test>
<test name="symlink04">
  <description>
  Verify that, symlink will succeed to create a symbolic link of an existing
  object name path.
  </description>
</test>
<test name="symlink05">
  <description>
  Verify that, symlink will succeed to create a symbolic link of an
  non-existing object name path.
  </description>
</test>
<test name="unlink05">
  <description>
  Basic test for the unlink(2) system call. 
  </description>
</test>
<test name="unlink06">
  <description>
  Test for the unlink(2) system call of a FIFO. 
  </description>
</test>
<test name="unlink07">
  <description>
  Tests for error handling for the unlink(2) system call. 
  </description>
</test>
<test name="unlink08">
  <description>
  More tests for error handling for the unlink(2) system call.
  </description>
</test>
<test name="linktest">
  <description>
  Regression test for max links per file
  </description>
</test>
<test name="rename01">
  <description>
  This test will verify the rename(2) syscall basic functionality.
  Verify rename() works when the "new" file or directory does not exist.
  </description>
</test>
<test name="rename02">
  <description>
  Basic test for the rename(2) system call
  </description>
</test>
<test name="rename03">
  <description>
  This test will verify that rename(2) functions correctly
  when the "new" file or directory exists
  </description>
</test>
<test name="rename04">
  <description>
  This test will verify that rename(2) failed when newpath is 
  a non-empty directory and return EEXIST or ENOTEMPTY
  </description>
</test>
<test name="rename05">
  <description>
  This test will verify that rename(2) fails with EISDIR
  </description>
</test>
<test name="rename06">
  <description>
  This test will verify that rename(2) failed in EINVAL
  </description>
</test>
<test name="rename07">
  <description>
  This test will verify that rename(2) failed in ENOTDIR
  </description>
</test>
<test name="rename08">
  <description>
  This test will verify that rename(2) syscall failed in EFAULT
  </description>
</test>
<test name="rename09">
  <description>
  check rename() fails with EACCES
  </description>
</test>
<test name="rename10">
  <description>
  This test will verify that rename(2) syscall fails with ENAMETOOLONG
  and ENOENT
  </description>
</test>
<test name="rename11">
  <description>
  This test will verify that rename(2) failed in EBUSY
  </description>
</test>
<test name="rename12">
  <description>
  check rename() fails with EPERM
  </description>
</test>
<test name="rename13">
  <description>
  Verify rename() return successfully and performs no other action
  when "old" file and "new" file link to the same file.
  </description>
</test>
<test name="rmdir01">
  <description>
  This test will verify that rmdir(2) syscall basic functionality.
  verify rmdir(2) returns a value of 0 and the directory being
  removed.
  </description>
</test>
<test name="rmdir02">
    <description>
    This test will verify that rmdir(2) fail in 
  1. ENOTEMPTY
  2. EBUSY
  3. ENAMETOOLONG
  4. ENOENT
  5. ENOTDIR
  6. EFAULT
  7. EFAULT
  </description>
</test>
<test name="rmdir03">
  <description>
  check rmdir() fails with EPERM or EACCES
  </description>
</test>
<test name="rmdir04">
  <description>
  Basic test for the rmdir(2) system call 
  </description>
</test>
<test name="rmdir05">
  <description>
  Verify that rmdir(2) returns a value of -1 and sets errno to indicate the error.
  </description>
</test>
<test name="mkdir01">
  <description>
  Basic errno test for mkdir(2) 
  </description>
</test>
<test name="mkdir02">
  <description>
  This test will verify that new directory created
  by mkdir(2) inherits the group ID from the parent
  directory and S_ISGID bit, if the S_ISGID bit is set
  in the parent directory.
  </description>
</test>
<test name="mkdir03">
  <description>
  Check mkdir() with various error conditions that should produce
  EFAULT, ENAMETOOLONG, EEXIST, ENOENT and ENOTDIR
  </description>
</test>
<test name="mkdir04">
  <description>
  Attempt to create a directory in a directory having no permissions. 
  </description>
</test>
<test name="mkdir05">
  <description>
  This test will verify the mkdir(2) syscall basic functionality
  </description>
</test>
<test name="mkdir08">
  <description>
  Basic test for mkdir(2)
  </description>
</test>
<test name="mknod01">
  <description>
  Basic test for mknod(2) 
  </description>
</test>
<test name="mknod02">
  <description>
  Verify that mknod(2) succeeds when used to create a filesystem 
  node with set group-ID bit set on a directory without set group-ID bit set.
  The node created should have set group-ID bit set and its gid should be 
  equal to that of its parent directory.
  </description>
</test>
<test name="mknod03">
  <description>
  Verify that mknod(2) succeeds when used to create a filesystem 
  node with set group-ID bit set on a directory with set group-ID bit set.
  The node created should have set group-ID bit set and its gid should be 
  equal to the effective gid of the process.
  </description>
</test>
<test name="mknod04">
  <description>
  Verify that mknod(2) succeeds when used to create a filesystem 
  node on a directory with set group-ID bit set.
  The node created should not have group-ID bit set and its gid should be 
  equal to the effective gid of the process.
  </description>
</test>
<test name="mknod05">
  <description>
  Verify that mknod(2) succeeds when used by root to create a filesystem 
  node with set group-ID bit set on a directory with set group-ID bit set.
  The node created should have set group-ID bit set and its gid should be 
  equal to that of its parent directory.
  </description>
</test>
<test name="mknod06">
  <description>
  Verify that,
  1) mknod(2) returns -1 and sets errno to EEXIST if specified path
  already exists.
  2) mknod(2) returns -1 and sets errno to EFAULT if pathname points
  outside user's accessible address space.
  3) mknod(2) returns -1 and sets errno to ENOENT if the directory 
  component in pathname does not exist.
  4) mknod(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
  component was too long.
  5) mknod(2) returns -1 and sets errno to ENOTDIR if the directory
  component in pathname is not a directory.
  </description>
</test>
<test name="mknod07">
  <description>
  Verify that,
  1) mknod(2) returns -1 and sets errno to EPERM if the process id of
  the caller is not super-user.
  2) mknod(2) returns -1 and sets errno to EACCES if parent directory
  does not allow  write  permission  to  the process.
  </description>
</test>
<test name="mknod08">
  <description>
  Verify that mknod(2) succeeds when used to create a filesystem 
  node on a directory without set group-ID bit set. The node created
  should not have set group-ID bit set and its gid should be equal to that
  of its parent directory.
  </description>
</test>
<test name="access01">
  <description>
  Basic test for access(2) using F_OK, R_OK, W_OK, and X_OK  arguments.
  </description>
</test>
<test name="access02">
  <description>
  Verify that access() succeeds to check the read/write/execute permissions
  on a file if the mode argument passed was R_OK/W_OK/X_OK.

  Also verify that, access() succeeds to test the accessibility of the file
  referred to by symbolic link if the pathname points to a symbolic link.
  </description>
</test>
<test name="access03">
  <description>
  EFAULT error testing for access(2).
  </description>
</test>
<test name="access04">
  <description>
  Verify that,
  1. access() fails with -1 return value and sets errno to EACCES
  if the permission bits of the file mode do not permit the
  requested (Read/Write/Execute) access.
  2. access() fails with -1 return value and sets errno to EINVAL
  if the specified access mode argument is invalid.
  3. access() fails with -1 return value and sets errno to EFAULT
  if the pathname points outside allocate address space for the
  process.
  4. access() fails with -1 return value and sets errno to ENOENT
  if the specified file doesn't exist (or pathname is NULL).
  5. access() fails with -1 return value and sets errno to ENAMETOOLONG
  if the pathname size is > PATH_MAX characters.
  </description>
</test>
<test name="access05">
  <description>
  Verify that access() succeeds to check the existence of a file if
  search access is permitted on the pathname of the specified file.
  </description>
</test>
<test name="access06">
  <description>
  EFAULT error testing for access(2).
  </description>
</test>
<test name="chroot01">
  <description>
  Testcase to check the whether chroot sets errno to EPERM.
  </description>
</test>
<test name="chroot02">
  <description>
  Test functionality of chroot(2)
  </description>
</test>
<test name="chroot03">
  <description>
  Testcase to test whether chroot(2) sets errno correctly.
  </description>
</test>
<test name="pipeio">
  <description>
  This tool can be used to beat on system or named pipes.
  See the help() function below for user information.
  </description>
</test>
<test name="pipe01">
  <description>
  Testcase to check the basic functionality of the pipe(2) syscall:
  Check that both ends of the pipe (both file descriptors) are
  available to a process opening the pipe.
  </description>
</test>
<test name="pipe05">
  <description>
  Check what happens when pipe is passed a bad file descriptor.
  </description>
</test>
<test name="pipe06">
  <description>
  Check what happens when the system runs out of pipes.
  </description>
</test>
<test name="pipe08">
  <description>
  Check that a SIGPIPE signal is generated when a write is
  attempted on an empty pipe.
  </description>
</test>
<test name="pipe09">
  <description>
  Check that two processes can use the same pipe at the same time.
  </description>
</test>
<test name="pipe10">
  <description>
  Check that parent can open a pipe and have a child read from it
  </description>
</test>
<test name="pipe11">
  <description>
  Check if many children can read what is written to a pipe by the
  parent.
  </description>
</test>
<test name="sem01">
  <description>
  Creates a semaphore and two processes.  The processes
  each go through a loop where they semdown, delay for a
  random amount of time, and semup, so they will almost
  always be fighting for control of the semaphore.
  </description>
</test>
<test name="sem02">
  <description>
  The application creates several threads using pthread_create().
  One thread performs a semop() with the SEM_UNDO flag set. The
  change in semaphore value performed by that semop should be
  "undone" only when the last pthread exits.
  </description>
</test>
<test name="semctl01">
  <description>
  test the 10 possible semctl() commands
  </description>
</test>
<test name="semctl02">
  <description>
  test for EACCES error
  </description>
</test>
<test name="semctl03">
  <description>
  test for EINVAL and EFAULT errors
  </description>
</test>
<test name="semctl04">
  <description>
  test for EPERM error
  </description>
</test>
<test name="semctl05">
  <description>
  test for ERANGE error
  </description>
</test>
<test name="semget01">
  <description>
  test that semget() correctly creates a semaphore set
  </description>
</test>
<test name="semget02">
  <description>
  test for EACCES and EEXIST errors
  </description>
</test>
<test name="semget03">
  <description>
  test for ENOENT error
  </description>
</test>
<test name="semget05">
  <description>
  test for ENOSPC error
  </description>
</test>
<test name="semget06">
  <description>
  test for EINVAL error
  </description>
</test>
<test name="semop01">
  <description>
  test that semop() basic functionality is correct
  </description>
</test>
<test name="semop02">
  <description>
  test for E2BIG, EACCES, EFAULT and EINVAL errors
  </description>
</test>
<test name="semop03">
  <description>
  test for EFBIG error
  </description>
</test>
<test name="semop04">
  <description>
  test for EAGAIN error
  </description>
</test>
<test name="semop05">
  <description>
  test for EINTR and EIDRM errors
  </description>
</test>
<test name="msgctl01">
  <description>
  create a message queue, then issue the IPC_STAT command
  and RMID commands to test the functionality
  </description>
</test>
<test name="msgctl02">
  <description>
  create a message queue, then issue the IPC_SET command
  to lower the msg_qbytes value.
  </description>
</test>
<test name="msgctl03">
  <description>
  create a message queue, then issue the IPC_RMID command
  </description>
</test>
<test name="msgctl04">
  <description>
  test for EACCES, EFAULT and EINVAL errors using
  a variety of incorrect calls.
  </description>
</test>
<test name="msgctl05">
  <description>
  test for EPERM error
  </description>
</test>
<test name="msgget01">
  <description>
  create a message queue, write a message to it and
  read it back.
  </description>
</test>
<test name="msgget02">
  <description>
  test for EEXIST and ENOENT errors
  </description>
</test>
<test name="msgget03">
  <description>
  test for an ENOSPC error by using up all available
  message queues.
  </description>
</test>
<test name="msgget04">
  <description>
  test for an EACCES error by creating a message queue
  with no read or write permission and then attempting
  to access it with various permissions.
  </description>
</test>
<test name="msgrcv01">
  <description>
  test that msgrcv() receives the expected message
  </description>
</test>
<test name="msgrcv02">
  <description>
  test for EACCES and EFAULT errors
  </description>
</test>
<test name="msgrcv03">
  <description>
  test for EINVAL error
  </description>
</test>
<test name="msgrcv04">
  <description>
  test for E2BIG and ENOMSG errors
  </description>
</test>
<test name="msgrcv05">
  <description>
  test for EINTR error
  </description>
</test>
<test name="msgrcv06">
  <description>
  test for EIDRM error
  </description>
</test>
<test name="msgsnd01">
  <description>
  test that msgsnd() enqueues a message correctly
  </description>
</test>
<test name="msgsnd02">
  <description>
  test for EACCES and EFAULT errors
  </description>
</test>
<test name="msgsnd03">
  <description>
  test for EINVAL error
  </description>
</test>
<test name="msgsnd04">
  <description>
  test for EAGAIN error
  </description>
</test>
<test name="msgsnd05">
  <description>
  test for EINTR error
  </description>
</test>
<test name="msgsnd06">
  <description>
  test for EIDRM error
  </description>
</test>
<test name="shmat01">
  <description>
  test that shmat() works correctly
  </description>
</test>
<test name="shmat02">
  <description>
  check for EINVAL and EACCES errors
  </description>
</test>
<test name="shmat03">
  <description>
  test for EACCES error
  </description>
</test>
<test name="shmctl01">
  <description>
  test the IPC_STAT, IPC_SET and IPC_RMID commands as
  they are used with shmctl()
  </description>
</test>
<test name="shmctl02">
  <description>
  check for EACCES, EFAULT and EINVAL errors
  </description>
</test>
<test name="shmctl03">
  <description>
  check for EACCES, and EPERM errors
  </description>
</test>
<test name="shmdt01">
  <description>
  check that shared memory is detached correctly
  </description>
</test>
<test name="shmdt02">
  <description>
  check for EINVAL error
  </description>
</test>
<test name="shmget01">
  <description>
  test that shmget() correctly creates a shared memory segment
  </description>
</test>
<test name="shmget02">
  <description>
  check for ENOENT, EEXIST and EINVAL errors
  </description>
</test>
<test name="shmget03">
  <description>
  test for ENOSPC error
  </description>
</test>
<test name="shmget04">
  <description>
  test for EACCES error
  </description>
</test>
<test name="shmget05">
  <description>
  test for EACCES error
  </description>
</test>
<test name="openfile">
  <description>
  Creates files and opens simultaneously
  </description>
</test>
<test name="open01">
  <description>
  Open a file with oflag = O_CREAT set, does it set the sticky bit off?

  Open "/tmp" with O_DIRECTORY, does it set the S_IFDIR bit on?
  </description>
</test>
<test name="open02">
  <description>
  Test if open without O_CREAT returns -1 if a file does not exist.
  </description>
</test>
<test name="open03">
  <description>
  Basic test for open(2)  
  </description>
</test>
<test name="open04">
  <description>
  Testcase to check that open(2) sets EMFILE if a process opens files
  more than its descriptor size
  </description>
</test>
<test name="open05">
  <description>
  Testcase to check open(2) sets errno to EACCES correctly.
  </description>
</test>
<test name="open06">
  <description>
  Testcase to check open(2) sets errno to ENXIO correctly.
  </description>
</test>
<test name="open07">
  <description>
  Test the open(2) system call to ensure that it sets ELOOP correctly.
  </description>
</test>
<test name="open08">
  <description>
  Check for the following errors:
  1.	EEXIST
  2.	EISDIR
  3.	ENOTDIR
  4.	ENAMETOOLONG
  5.	EFAULT
  6.	ETXTBSY
  </description>
</test>
<test name="openfile">
  <description>
  Creates files and opens simultaneously
  </description>
</test>
<test name="chdir01">
  <description>
  Check proper operation of chdir(): tests whether the
  system call can it change the current, working directory, and find a
  file there? Will it fail on a non-directory entry ?
  </description>
</test>
<test name="chdir02">
  <description>
  Basic test for chdir(2).
  </description>
</test>
<test name="chdir03">
  <description>
  Testcase for testing that chdir(2) sets EACCES errno
  </description>
</test>
<test name="chdir04">
  <description>
  Testcase to test whether chdir(2) sets errno correctly.
  </description>
</test>
<test name="chmod01">
  <description>
  Verify that, chmod(2) succeeds when used to change the mode permissions
  of a file. 
  </description>
</test>
<test name="chmod02">
  <description>
  Basic test for chmod(2).
  </description>
</test>
<test name="chmod03">
  <description>
  Verify that, chmod(2) will succeed to change the mode of a file
  and set the sticky bit on it if invoked by non-root (uid != 0)
  process with the following constraints,
  - the process is the owner of the file.
  - the effective group ID or one of the supplementary group ID's of the
  process is equal to the group ID of the file.
  </description>
</test>
<test name="chmod04">
  <description>
  Verify that, chmod(2) will succeed to change the mode of a directory
  and set the sticky bit on it if invoked by non-root (uid != 0) process
  with the following constraints,
  - the process is the owner of the directory.
  - the effective group ID or one of the supplementary group ID's of the
  process is equal to the group ID of the directory.
  </description>
</test>
<test name="chmod05">
  <description>
  Verify that, chmod(2) will succeed to change the mode of a directory
  but fails to set the setgid bit on it if invoked by non-root (uid != 0)
  process with the following constraints,
  - the process is the owner of the directory.
  - the effective group ID or one of the supplementary group ID's of the
  process is not equal to the group ID of the directory.
  </description>
</test>
<test name="chmod06">
  <description>
  Verify that,
  1) chmod(2) returns -1 and sets errno to EPERM if the effective user id
  of process does not match the owner of the file and the process is
  not super user.
  2) chmod(2) returns -1 and sets errno to EACCES if search permission is
  denied on a component of the path prefix.
  3) chmod(2) returns -1 and sets errno to EFAULT if pathname points
  outside user's accessible address space.
  4) chmod(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
  component is too long.
  5) chmod(2) returns -1 and sets errno to ENOTDIR if the directory
  component in pathname is not a directory.
  6) chmod(2) returns -1 and sets errno to ENOENT if the specified file
  does not exists.
  </description>
</test>
<test name="chmod07">
  <description>
  Verify that, chmod(2) will succeed to change the mode of a file/directory
  and sets the sticky bit on it if invoked by root (uid = 0) process with
  the following constraints,
  - the process is not the owner of the file/directory.
  - the effective group ID or one of the supplementary group ID's of the
  process is equal to the group ID of the file/directory.
  </description>
</test>
<test name="chown01">
  <description>
  Basic test for chown(2).
  </description>
</test>
<test name="chown02">
  <description>
  Verify that, when chown(2) invoked by super-user to change the owner and
  group of a file specified by path to any numeric owner(uid)/group(gid)
  values,
  - clears setuid and setgid bits set on an executable file.
  - preserves setgid bit set on a non-group-executable file.
  </description>
</test>
<test name="chown03">
  <description>
  Verify that, chown(2) succeeds to change the group of a file specified
  by path when called by non-root user with the following constraints,
  - euid of the process is equal to the owner of the file.	 
  - the intended gid is either egid, or one of the supplementary gids
  of the process.
  Also, verify that chown() clears the setuid/setgid bits set on the file.
  </description>
</test>
<test name="chown04">
  <description>
  Verify that,
  1) chown(2) returns -1 and sets errno to EPERM if the effective user id
  of process does not match the owner of the file and the process is
  not super user.
  2) chown(2) returns -1 and sets errno to EACCES if search permission is
  denied on a component of the path prefix.
  3) chown(2) returns -1 and sets errno to EFAULT if pathname points
  outside user's accessible address space.
  4) chown(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
  component is too long.
  5) chown(2) returns -1 and sets errno to ENOTDIR if the directory
  component in pathname is not a directory.
  6) chown(2) returns -1 and sets errno to ENOENT if the specified file
  does not exists.
  </description>
</test>
<test name="chown05">
  <description>
  Verify that, chown(2) succeeds to change the owner and group of a file
  specified by path to any numeric owner(uid)/group(gid) values when invoked 
  by super-user.
  </description>
</test>
<test name="close01">
  <description>
  Test that closing a regular file and a pipe works correctly
  </description>
</test>
<test name="close02">
  <description>
  Check that an invalid file descriptor returns EBADF
  </description>
</test>
<test name="close08">
  <description>
  Basic test for close(2).
  </description>
</test>
<test name="fchdir01">
  <description>
  create a directory and cd into it.
  </description>
</test>
<test name="fchdir02">
  <description>
  try to cd into a bad directory (bad fd).
  </description>
</test>
<test name="fchmod01">
  <description>
  Basic test for Fchmod(2).
  </description>
</test>
<test name="fchmod02">
  <description>
  Verify that, fchmod(2) will succeed to change the mode of a file/directory
  set the sticky bit on it if invoked by root (uid = 0) process with
  the following constraints,
  - the process is not the owner of the file/directory.
  - the effective group ID or one of the supplementary group ID's of the
  process is equal to the group ID of the file/directory.
  </description>
</test>
<test name="fchmod03">
  <description>
  Verify that, fchmod(2) will succeed to change the mode of a file
  and set the sticky bit on it if invoked by non-root (uid != 0)
  process with the following constraints,
  - the process is the owner of the file.
  - the effective group ID or one of the supplementary group ID's of the
  process is equal to the group ID of the file.
  </description>
</test>
<test name="fchmod04">
  <description>
  Verify that, fchmod(2) will succeed to change the mode of a directory
  and set the sticky bit on it if invoked by non-root (uid != 0) process
  with the following constraints,
  - the process is the owner of the directory.
  - the effective group ID or one of the supplementary group ID's of the
  process is equal to the group ID of the directory.
  </description>
</test>
<test name="fchmod05">
  <description>
  Verify that, fchmod(2) will succeed to change the mode of a directory
  but fails to set the setgid bit on it if invoked by non-root (uid != 0)
  process with the following constraints,
  - the process is the owner of the directory.
  - the effective group ID or one of the supplementary group ID's of the
  process is not equal to the group ID of the directory.
  </description>
</test>
<test name="fchmod06">
  <description>
  Verify that,
  1) fchmod(2) returns -1 and sets errno to EPERM if the effective user id
  of process does not match the owner of the file and the process is
  not super user.
  2) fchmod(2) returns -1 and sets errno to EBADF if the file descriptor
  of the specified file is not valid.
  </description>
</test>
<test name="fchmod07">
  <description>
  Verify that, fchmod(2) succeeds when used to change the mode permissions
  of a file specified by file descriptor. 
  </description>
</test>
<test name="fchown01">
  <description>
  Basic test for fchown(2).
  </description>
</test>
<test name="fchown02">
  <description>
  Verify that, when fchown(2) invoked by super-user to change the owner and
  group of a file specified by file descriptor to any numeric 
  owner(uid)/group(gid) values,
  - clears setuid and setgid bits set on an executable file.
  - preserves setgid bit set on a non-group-executable file.
  </description>
</test>
<test name="fchown03">
  <description>
  Verify that, fchown(2) succeeds to change the group of a file specified
  by path when called by non-root user with the following constraints,
  - euid of the process is equal to the owner of the file.	 
  - the intended gid is either egid, or one of the supplementary gids
  of the process.
  Also, verify that fchown() clears the setuid/setgid bits set on the file.
  </description>
</test>
<test name="fchown04">
  <description>
  Verify that,
  1) fchown(2) returns -1 and sets errno to EPERM if the effective user id
  of process does not match the owner of the file and the process is
  not super user.
  2) fchown(2) returns -1 and sets errno to EBADF if the file descriptor
  of the specified file is not valid.
  </description>
</test>
<test name="fchown05">
  <description>
  Verify that, fchown(2) succeeds to change the owner and group of a file
  specified by file descriptor to any numeric owner(uid)/group(gid) values 
  when invoked by super-user.
  </description>
</test>
<test name="lchown01">
  <description>
  Verify that, lchown(2) succeeds to change the owner and group of a file
  specified by path to any numeric owner(uid)/group(gid) values when invoked 
  by super-user.
  </description>
</test>
<test name="lchown02">
  <description>
  Verify that,
  1) lchown(2) returns -1 and sets errno to EPERM if the effective user id
  of process does not match the owner of the file and the process is
  not super user.
  2) lchown(2) returns -1 and sets errno to EACCES if search permission is
  denied on a component of the path prefix.
  3) lchown(2) returns -1 and sets errno to EFAULT if pathname points
  outside user's accessible address space.
  4) lchown(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
  component is too long.
  5) lchown(2) returns -1 and sets errno to ENOTDIR if the directory
  component in pathname is not a directory.
  6) lchown(2) returns -1 and sets errno to ENOENT if the specified file
  does not exists.
  </description>
</test>
<test name="creat01">
  <description>
  Testcase to check the basic functionality of the creat(2) system call.
  </description>
</test>
<test name="creat03">
  <description>
  Testcase to check whether the sticky bit cleared.
  </description>
</test>
<test name="creat04">
  <description>
  Testcase to check creat(2) fails with EACCES
  </description>
</test>
<test name="creat05">
  <description>
  Testcase to check that creat(2) system call returns EMFILE.
  </description>
</test>
<test name="creat06">
  <description>
  Testcase to check creat(2) sets the following errnos correctly:
  1.	EISDIR
  2.	ENAMETOOLONG
  3.	ENOENT
  4.	ENOTDIR
  5.	EFAULT
  6.	EACCES
  </description>
</test>
<test name="creat07">
  <description>
  Testcase to check creat(2) sets the following errnos correctly:
  1.	ETXTBSY
  </description>
</test>
<test name="creat09">
  <description>
  Basic test for creat(2) using 0700 argument.
  </description>
</test>
<test name="truncate01">
  <description>
  Verify that, truncate(2) succeeds to truncate a file to a specified
  length.
  </description>
</test>
<test name="truncate02">
  <description>
  Verify that, truncate(2) succeeds to truncate a file to a certain length,
  but the attempt to read past the truncated length will fail.  
  </description>
</test>
<test name="truncate03">
  <description>
  Verify that,
  1) truncate(2) returns -1 and sets errno to EACCES if search/write
  permission denied for the process on the component of the path prefix
  	or named file.
  2) truncate(2) returns -1 and sets errno to ENOTDIR if the component of
  the path prefix is not a directory.
  3) truncate(2) returns -1 and sets errno to EFAULT if pathname points
  outside user's accessible address space.
  4) truncate(2) returns -1 and sets errno to ENAMETOOLONG if the component
  of a pathname exceeded 255 characters or entire pathname exceeds 1023
  characters.
  5) truncate(2) returns -1 and sets errno to ENOENT if the named file
  does not exist.
  </description>
</test>
<test name="ftruncate01">
  <description>
  Verify that, ftruncate(2) succeeds to truncate a file to a specified
  length if the file indicated by file descriptor opened for writing.
  </description>
</test>
<test name="ftruncate02">
  <description>
  Verify that, ftruncate(2) succeeds to truncate a file to a certain length,
  but the attempt to read past the truncated length will fail.  
  </description>
</test>
<test name="ftruncate03">
  <description>
  Verify that,
  1) ftruncate(2) returns -1 and sets errno to EINVAL if the specified
  truncate length is less than 0.
  2) ftruncate(2) returns -1 and sets errno to EBADF if the file descriptor
  of the specified file is not valid.
  </description>
</test>
<test name="vhangup01">
  <description>
  Check the return value, and errno of vhangup(2)
  when a non-root user calls vhangup().
  </description>
</test>
<test name="vhangup02">
  <description>
  To test the basic functionality of vhangup(2)
  </description>
</test>
<test name="growfiles">
  This program will grow a list of files.
  Each file will grow by grow_incr before the same
  file grows twice.  Each file is open and closed before next file is opened.
  </description>
</test>
<test name="pipe01">
  <description>
  Testcase to check the basic functionality of the pipe(2) syscall:
  Check that both ends of the pipe (both file descriptors) are
  available to a process opening the pipe.
  </description>
</test>
<test name="pipe05">
  <description>
  Check what happens when pipe is passed a bad file descriptor.
  </description>
</test>
<test name="pipe06">
  <description>
  Check what happens when the system runs out of pipes.
  </description>
</test>
<test name="pipe08">
  <description>
  Check that a SIGPIPE signal is generated when a write is
  attempted on an empty pipe.
  </description>
</test>
<test name="pipe09">
  <description>
  Check that two processes can use the same pipe at the same time.
  </description>
</test>
<test name="pipe10">
  <description>
  Check that parent can open a pipe and have a child read from it
  </description>
</test>
<test name="pipe11">
  <description>
  Check if many children can read what is written to a pipe by the
  parent.
  </description>
</test>
<test name="pipeio">
  <description>
  This tool can be used to beat on system or named pipes.
  See the help() function below for user information.

  /ipc_stress/message_queue_test_01.c
  /ipc_stress/pipe_test_01.c
  /ipc_stress/semaphore_test_01.c
  /ipc_stress/single_test_01.c
  </description>
</test>
<test name="proc01">
  <description>
  Recursively reads all files within /proc filesystem.
  </description>
</test>
<test name="lftest">
  <description>
  The purpose of this test is to verify the file size limitations of a filesystem.
  It writes one buffer at a time and lseeks from the beginning of the file to the
  end of the last write position.  The intent is to test lseek64.
  </description>
</test>
<test name="llseek01">
  <description>
  Verify that, llseek() call succeeds to set the file pointer position 
  to an offset larger than file size. Also, verify that any attempt
  to write to this location fails.
  </description>
</test>
<test name="llseek02">
  <description>
  Verify that,
  1. llseek() returns -1 and sets errno to EINVAL, if the 'Whence' argument
  is not a proper value.
  2. llseek() returns -1 and sets errno to EBADF, if the file handle of
  the specified file is not valid.
  </description>
</test>
<test name="lseek01">
  <description>
  Basic test for lseek(2) 
  </description>
</test>
<test name="lseek02">
  <description>
  Negative test for lseek(2) 
  </description>
</test>
<test name="lseek03">
  <description>
  Negative test for lseek(2) whence
  </description>
</test>
<test name="lseek04">
  <description>
  Negative test for lseek(2) of a fifo 
  </description>
</test>
<test name="lseek05">
  <description>
  Negative test for lseek(2) of a pipe
  </description>
</test>
<test name="lseek06">
  <description>
  Verify that, lseek() call succeeds to set the file pointer position 
  to less  than  or equal to the file size, when a file is opened for
  read or write.
  </description>
</test>
<test name="lseek07">
  <description>
  Verify that, lseek() call succeeds to set the file pointer position
  to more than the file size, when a file is opened for reading/writing.
  </description>
</test>
<test name="lseek08">
  <description>
  Verify that, lseek() call succeeds to set the file pointer position 
  to the end of the file when 'whence' value set to SEEK_END and any
  attempts to read from that position should fail.
  </description>
</test>
<test name="lseek09">
  <description>
  Verify that, lseek() call succeeds to set the file pointer position 
  to the current specified location, when 'whence' value is set to
  SEEK_CUR and the data read from the specified location should match
  the expected data.
  </description>
</test>
<test name="lseek10">
  <description>
  Verify that,
  1. lseek() returns -1 and sets errno to ESPIPE, if the file handle of
  the specified file is associated with a pipe, socket, or  FIFO.	
  2. lseek() returns -1 and sets errno to EINVAL, if the 'Whence' argument
  is not a proper value.
  3. lseek() returns -1 and sets errno to EBADF, if the file handle of
  the specified file is not valid.
  </description>
</test>
<test name="rwtest">
  <description>
  A wrapper for doio and iogen.
  </description>
</test>
<test name="doio">
  <description>
  a general purpose io initiator with system call and
  write logging.  See doio.h for the structure which defines
  what doio requests should look like.

  Currently doio can handle read,write,reada,writea,ssread,
  sswrite, and many varieties of listio requests.
  For disk io, if the O_SSD flag is set doio will allocate
  the appropriate amount of ssd and do the transfer - thus, doio
  can handle all of the primitive types of file io.
  </description>
</test>
<test name="iogen">
  <description>
  A tool for generating file/sds io for a doio process
  </description>
</test>
<test name="pread01">
  <description>
  Verify the functionality of pread() by writing known data using pwrite()
  to the file at various specified offsets and later read from the file from
  various specified offsets, comparing the data read against the data 
  written.
  </description>
</test>
<test name="pread02">
  <description>
  Verify that,
  1) pread() fails when attempted to read from an unnamed pipe.
  2) pread() fails if the specified offset position was invalid.
  </description>
</test>
<test name="pwrite01">
  <description>
  Verify the functionality of pwrite() by writing known data using pwrite()
  to the file at various specified offsets and later read from the file from
  various specified offsets, comparing the data written against the data
  read using read().
  </description>
</test>
<test name="pwrite02">
  <description>
  Verify that,
  1) pwrite() fails when attempted to write to an unnamed pipe.
  2) pwrite() fails if the specified offset position was invalid.
  </description>
</test>
<test name="read01">
  <description>
  Basic test for the read(2) system call
  </description>
</test>
<test name="read02">
  <description>
  test 1: Does read return -1 if file descriptor is not valid, check for EBADF

  test 2: Check if read sets EISDIR, if the fd refers to a directory

  test 3: Check if read sets EFAULT, if buf is -1.
  </description>
</test>
<test name="read03">
  <description>
  Testcase to check that read() sets errno to EAGAIN
  </description>
</test>
<test name="read04">
  <description>
  Testcase to check if read returns the number of bytes read correctly.
  </description>
</test>
<test name="readv01">
  <description>
  Testcase to check the basic functionality of the readv(2) system call.
  </description>
</test>
<test name="readv02">
  <description>
  Testcase to check the error conditions of the readv(2) system call.
  </description>
</test>
<test name="write01">
  <description>
  Basic test for write(2) system call.
  </description>
</test>
<test name="write02">
  <description>
  Basic functionality test: does the return from write match the count
  of the number of bytes written.
  </description>
</test>
<test name="write03">
  <description>
  Testcase to check that write(2) doesn't corrupt a file when it fails
  </description>
</test>
<test name="write04">
  <description>
  Testcase to check that write() sets errno to EAGAIN
  </description>
</test>
<test name="write05">
  <description>
  Check the return value, and errnos of write(2)
  - when the file descriptor is invalid - EBADF
  - when the buf parameter is invalid - EFAULT
  - on an attempt to write to a pipe that is not open for reading - EPIPE
  </description>
</test>
<test name="writev01">
  <description>
  Testcase to check the basic functionality of writev(2) system call.
  </description>
</test>
<test name="writev02">
  <description>
  In these testcases, writev() is called with partially valid data 
  to be written in a sparse file.
  </description>
</test>
<test name="writev03">
  <description>
  The testcases are written calling writev() with partially valid data
  to overwrite the contents, to write in the beginning and to write in
  the end of the file.
  </description>
</test>
<test name="writev04">
  <description>
  The testcases are written calling writev() with partially valid data
  to overwrite the contents, to write in the beginning and to write in
  the end of the file. This is same as writev03, but the length of
  buffer used here is 8192 bytes.
  </description>
</test>
<test name="writev05">
  <description>
  These testcases are written to test writev() on sparse files. This
  is same as writev02. But the initial write() with valid data is
  done at the beginning of the file.
  </description>
</test>
<test name="disktest">
  <description>
  Does repeated accesses to a filespec and optionally writes to, reads from,
  and  verifies  the  data.  By default, disktest makes assumptions about
  the running environment which allows for a quick start of IO generation.
  However, Disktest has  a  large  number  of command line options which can
  be used to adapt the test for a variety of uses including data integrity,
  medium integrity, performance, and  simple application simulation.
  </description>
</test>
<test name="getdents01">
  <description>
  get a directory entry
  </description>
</test>
<test name="getdents02">
  <description>
  check that we get a failure with a bad file descriptor
  </description>
</test>
<test name="getdents03">
  <description>
  check for an EINVAL error
  </description>
</test>
<test name="getdents04">
  <description>
  check for an ENOTDIR error
  </description>
</test>
<test name="getdents05">
  <description>
  check that we get a failure with a bad dirp address.
  </description>
</test>
<test name="process_stress">
  <description>
  Spawn creates a tree
  of processes with Dval depth and Bval breadth.  Each parent will spawn
  Bval children.  Each child will store information about themselves
  in shared memory.  The leaf nodes will communicate the existence
  of one another through message queues, once each leaf node has
  received communication from all of her siblings she will reduce
  the semaphore count and exit.  Meanwhile all parents are waiting
  to hear from their children through the use of semaphores.  When
  the semaphore count reaches zero then the parent knows all the
  children have talked to one another.  Locking of the connter semaphore
  is provided by the use of another (binary) semaphore.
  </description>
</test>
<test name="sched_stress">
  <description>
  Exports required environment variables and runs sched_driver
  </description>
</test>
<test name="sched_driver">
  <description>
  This program uses system calls to change the 
  priorities of the throughput measurement testcases.  
  When real-time is in effect, priorities 50 through 64
  are used.  (MAX_PRI and MIN_PRI)  When user-time     
  (normal) is in effect, 0-14 (corresponding to nice()  
  calls) is used.  The driver only keeps track of      
  values from 50 to 64, and the testcases will scale   
  them down to 0 to 14 when needed, to change the      
  priority of a user-time process.                       
  </description>
</test>
<test name="time-schedule">
  <description>
  This programme will determine the context switch 
  (scheduling) overhead on a system. It takes into 
  account SMP machines. True context switches are 
  measured.
  </description>
</test>
<test name="trace_sched">
  <description>
  This utility spawns N tasks, each task sets its priority 
  by making a system call to the scheduler. The thread 
  function reads the priority that the scheduler sets for 
  this task and also reads from /proc the processor this 
  task last executed on the information that is gathered 
  by the thread function may be in real-time. Its only an 
  approximation.         
  </description>
</test>
<test name="sched_getscheduler01">
  <description>
  Testcase to check sched_getscheduler() returns correct return value 
  </description>
</test>
<test name="sched_getscheduler02">
  <description>
  To check for the errno ESRCH
  </description>
</test>
<test name="sched_setscheduler01">
  <description>
  Testcase to test whether sched_setscheduler(2) sets the errnos
  correctly.
  </description>
</test>
<test name="sched_setscheduler02">
  <description>
  Testcase to test whether sched_setscheduler(2) sets the errnos
  correctly.
  </description>
</test>
<test name="sched_yield01">
  <description>
  Testcase to check that sched_yield returns correct values.
  </description>
</test>
<test name="nice01">
  <description>
  Verify that root can provide a negative value  to nice()
  and hence root can decrease the nice value of the process
  using nice() system call
  </description>
</test>
<test name="nice02">
  <description>
  Verify that any user can successfully increase the nice value of
  the process by passing a higher increment value (> max. applicable limits)
  to nice() system call.
  </description>
</test>
<test name="nice03">
  <description>
  Verify that any user can successfully increase the nice value of
  the process by passing an increment value (< max. applicable limits) to 
  nice() system call.
  </description>
</test>
<test name="nice04">
  <description>
  Verify that, nice(2) fails when, a non-root user attempts to increase
  the priority of a process by specifying a negative increment value.
  </description>
</test>
<test name="nice05">
  <description>
  Basic test for nice(2) 
  </description>
</test>
<test name="poll01">
  <description>
  Verify that valid open file descriptor must be provided to poll() to
  succeed.
  </description>
</test>
<test name="select01">
  <description>
  Basic test for the select(2) system call to a fd of regular file with no I/O 
  and small timeout 
  </description>
</test>
<test name="select02">
  <description>
  Basic test for the select(2) system call to fd of system pipe with no I/O 
  and small timeout 
  </description>
</test>
<test name="select03">
  <description>
  Basic test for the select(2) system call to fd of a named-pipe (FIFO) 
  </description>
</test>
<test name="select04">
  <description>
  Verify that select(2) returns immediately (does not block) if the
  timeout value is zero.
  </description>
</test>
<test name="select05">
  <description>
  Verify that select(2) fails when one or more of the file descriptor sets
  specify a file descriptor which is not valid.
  </description>
</test>
<test name="select06">
  <description>
  Verify that select(2) fails when a signal is delivered before any of the
  selected events occur and before the timeout interval expires.
  </description>
</test>
<test name="select07">
  <description>
  Verify that select(2) fails when an invalid timeout interval is specified.
  </description>
</test>
<test name="select08">
  <description>
  Verify the functionality of select(2) by passing non-null writefds
  which points to a regular file, pipes or FIFO's.
  </description>
</test>
<test name="select09">
  <description>
  Verify the functionality of select(2) by passing non-null readfds
  which points to a regular file, pipes or FIFO's.
  </description>
</test>
<test name="select10">
  <description>
  Verify that a successful call to select() shall return the desired 
  number of modified descriptors for which bits are set in the bit masks, 
  where descriptors points to a regular file, pipes or FIFO's.
  </description>
</test>
<test name="sem01">
  <description>
  Creates a semaphore and two processes.  The processes
  each go through a loop where they semdown, delay for a
  random amount of time, and semup, so they will almost
  always be fighting for control of the semaphore.
  </description>
</test>
<test name="sem02">
  <description>
  The application creates several threads using pthread_create().
  One thread performs a semop() with the SEM_UNDO flag set. The
  change in semaphore value performed by that semop should be
  "undone" only when the last pthread exits.
  </description>
</test>
<test name="semctl01">
  <description>
  test the 10 possible semctl() commands
  </description>
</test>
<test name="semctl02">
  <description>
  test for EACCES error
  </description>
</test>
<test name="semctl03">
  <description>
  test for EINVAL and EFAULT errors
  </description>
</test>
<test name="semctl04">
  <description>
  test for EPERM error
  </description>
</test>
<test name="semctl05">
  <description>
  test for ERANGE error
  </description>
</test>
<test name="semget01">
  <description>
  test that semget() correctly creates a semaphore set
  </description>
</test>
<test name="semget02">
  <description>
  test for EACCES and EEXIST errors
  </description>
</test>
<test name="semget03">
  <description>
  test for ENOENT error
  </description>
</test>
<test name="semget05">
  <description>
  test for ENOSPC error
  </description>
</test>
<test name="semget06">
  <description>
  test for EINVAL error
  </description>
</test>
<test name="semop01">
  <description>
  test that semop() basic functionality is correct
  </description>
</test>
<test name="semop02">
  <description>
  test for E2BIG, EACCES, EFAULT and EINVAL errors
  </description>
</test>
<test name="semop03">
  <description>
  test for EFBIG error
<test name="semop04">
  <description>
  test for EAGAIN error
  </description>
</test>
<testi name="semop05">
  <description>
  test for EINTR and EIDRM errors
  </description>
</test>
<test name="shmat01">
  <description>
  test that shmat() works correctly
  </description>
</test>
<test name="shmat02">
  <description>
  check for EINVAL and EACCES errors
  </description>
</test>
<test name="shmat03">
  <description>
  test for EACCES error
  </description>
</test>
<test name="shmctl01">
  <description>
  test the IPC_STAT, IPC_SET and IPC_RMID commands as
  they are used with shmctl()
  </description>
</test>
<test name="shmctl02">
  <description>
  check for EACCES, EFAULT and EINVAL errors
  </description>
</test>
<test name="shmctl03">
  <description>
  check for EACCES, and EPERM errors
  </description>
</test>
<test name="shmdt01">
  <description>
  check that shared memory is detached correctly
  </description>
</test>
<test name="shmdt02">
  <description>
  check for EINVAL error
  </description>
</test>
<test name="shmget01">
  <description>
  test that shmget() correctly creates a shared memory segment
  </description>
</test>
<test name="shmget02">
  <description>
  check for ENOENT, EEXIST and EINVAL errors
  </description>
</test>
<test name="shmget03">
  <description>
  test for ENOSPC error
  </description>
</test>
<test name="shmget04">
  <description>
  test for EACCES error
  </description>
</test>
<test name="shmget05">
  <description>
  test for EACCES error
  </description>
</test>
<test name="shmat1">
  <description>
  Test the LINUX memory manager. The program is aimed at
  stressing the memory manager by repeated shmat/write/read/
  shmatd of file/memory of random size (maximum 1000 * 4096)
  done by multiple processes.
  </description>
</test>
<test name="shm_test">
  <description>
  This program is designed to stress the Memory management sub -
  system of Linux. This program will spawn multiple pairs of
  reader and writer threads. One thread will create the shared
  segment of random size and write to this memory, the other
  pair will read from this memory.
  </description>
</test>
<test name="sigaction01">
  <description>
  Test some features of sigaction (see below for more details)
  </description>
</test>
<test name="sigaction02">
  <description>
  Testcase to check the basic errnos set by the sigaction(2) syscall.
  </description>
</test>
<test name="sigaltstack01">
  <description>
  Send a signal using the main stack. While executing the signal handler
  compare a variable's address lying on the main stack with the stack
  boundaries returned by sigaltstack().
  </description>
</test>
<test name="sigaltstack02">
  <description>
  Verify that,
  1. sigaltstack() fails and sets errno to EINVAL when "ss_flags" field
  pointed to by 'ss' contains invalid flags.
  2. sigaltstack() fails and sets errno to ENOMEM when the size of alternate
  stack area is less than MINSIGSTKSZ.
  </description>
</test>
<test name="sighold02">
  <description>
  Basic test for the sighold02(2) system call. 
  </description>
</test>
<test name="signal01">
  <description>
  set the signal handler to our own function
  </description>
</test>
<test name="signal02">
  <description>
  Test that we get an error using illegal signals
  </description>
</test>
<test name="signal03">
  <description>
  Boundary value and other invalid value checking of signal setup and signal 
  sending. 
  </description>
</test>
<test name="signal04">
  <description>
  restore signals to default behavior
  </description>
</test>
<test name="signal05">
  <description>
  set signals to be ignored
  </description>
</test>
<test name="sigprocmask01">
  <description>
  Verify that sigprocmask() succeeds to examine and change the calling
  process's signal mask. 
  Also, verify that sigpending() succeeds to store signal mask that are
  blocked from delivery and pending for the calling process.
  </description>
</test>
<test name="sigrelse01">
  <description>
  Basic test for the sigrelse(2) system call. 
  </description>
</test>
<test name="sigsuspend01">
  <description>
  Verify that sigsuspend() succeeds to change process's current signal
  mask with the specified signal mask and suspends the process execution
  until the delivery of a signal.
  </description>
</test>
<test name="kill01">
  <description>
  Test case to check the basic functionality of kill().
  </description>
</test>
<test name="kill02">
  <description>
  Sending a signal to processes with the same process group ID
  </description>
</test>
<test name="kill03">
  <description>
  Test case to check that kill fails when given an invalid signal.
  </description>
</test>
<test name="kill04">
  <description>
  Test case to check that kill() fails when passed a non-existent pid.
  </description>
</test>
<test name="kill05">
  <description>
  Test case to check that kill() fails when passed a pid owned by another
  user.
  </description>
</test>
<test name="kill06">
  <description>
  Test case to check the basic functionality of kill() when killing an
  entire process group with a negative pid.
  </description>
</test>
<test name="kill07">
  <description>
  Test case to check that SIGKILL can not be caught.
  </description>
</test>
<test name="kill08">
  <description>
  Test case to check the basic functionality of kill() when kill an
  entire process group.
  </description>
</test>
<test name="kill09">
  <description>
  Basic test for kill(2)
  </description>
</test>
<test name="kill10">
  <description>
  Signal flooding test.
  </description>
</test>
<test name="mtest01">
   <description>
   mallocs memory &lt;chunksize&gt; at a time until malloc fails.
  </description>
</test>
<test name="mallocstress">
   <description>
   This program is designed to stress the VMM by doing repeated  */
  mallocs and frees, with out using the swap space. This is     */
  achieved by spawning N threads with repeatedly malloc and free*/
  a memory of size M. The stress can be increased by increasing */
  the number of repetitions over the default number using the   */
  -l [num] option.
  </description>
</test>
<test name="clisrv">
  <description>
  Sender: Read contents of data file. Write each line to socket, then
  read line back from socket and write to standard output.      
  Receiver: Read a stream socket one line at a time and write each line
  back to the sender.                                       
  Usage:       pthcli [port number]                 
  </description>
</test>
<test name="socket01">
  <description>
  Verify that socket() returns the proper errno for various failure cases
  </description>
</test>
<test name="socketpair01">
  <description>
  Verify that socketpair() returns the proper errno for various failure cases
  </description>
</test>
<test name="sockioctl01">
  <description>
  Verify that ioctl() on sockets returns the proper errno for various
  failure cases
  </description>
</test>
<test name="connect01">
  <description>
  Verify that connect() returns the proper errno for various failure cases
  </description>
</test>
<test name="getpeername01">
  <description>
  Verify that getpeername() returns the proper errno for various failure cases
  </description>
</test>
<test name="getsockname01">
  <description>
  Verify that getsockname() returns the proper errno for various failure cases
  </description>
</test>
<test name="getsockopt01">
  <description>
  Verify that getsockopt() returns the proper errno for various failure cases
  </description>
</test>
<test name="listen01">
  <description>
  Verify that listen() returns the proper errno for various failure cases
  </description>
</test>
<test name="accept01">
  <description>
  Verify that accept() returns the proper errno for various failure cases
  </description>
</test>
<test name="bind01">
  <description>
  Verify that bind() returns the proper errno for various failure cases
  </description>
</test>
<test name="recv01">
  <description>
  Verify that recv() returns the proper errno for various failure cases
  </description>
</test>
<test name="recvfrom01">
  <description>
  Verify that recvfrom() returns the proper errno for various failure cases
  </description>
</test>
<test name="recvmsg01">
  <description>
  Verify that recvmsg() returns the proper errno for various failure cases
  </description>
</test>
<test name="send01">
  <description>
  Verify that send() returns the proper errno for various failure cases
  </description>
</test>
<test name="sendmsg01">
  <description>
  Verify that sendmsg() returns the proper errno for various failure cases
  </description>
</test>
<test name="sendto01">
  <description>
  Verify that sendto() returns the proper errno for various failure cases
  </description>
</test>
<test name="setsockopt01">
  <description>
  Verify that setsockopt() returns the proper errno for various failure cases
  </description>
</test>
<test name="fstat01">
  <description>
  Basic test for fstat(2)
  </description>
</test>
<test name="fstat02">
  <description>
  Verify that, fstat(2) succeeds to get the status of a file and fills
  the stat structure elements though file pointed to by file descriptor
  not opened for reading.
  </description>
</test>
<test name="fstat03">
  <description>
  Verify that, fstat(2) returns -1 and sets errno to EBADF if the file 
  pointed to by file descriptor is not valid.
  </description>
</test>
<test name="fstat04">
  <description>
  Verify that, fstat(2) succeeds to get the status of a file pointed by
  file descriptor and fills the stat structure elements.
  </description>
</test>
<test name="fstatfs01">
  <description>
  Basic test for fstatfs(2)
  </description>
</test>
<test name="fstatfs02">
  <description>
  Testcase to check fstatfs() sets errno correctly.
  </description>
</test>
<test name="lstat01">
  <description>
  Verify that, lstat(2) succeeds to get the status of a file pointed to by
  symlink and fills the stat structure elements.
  </description>
</test>
<test name="lstat02">
  <description>
  Basic test for lstat(2) 
  </description>
</test>
<test name="lstat03">
  <description>
  Verify that,
  1) lstat(2) returns -1 and sets errno to EACCES if search permission is
  denied on a component of the path prefix.
  2) lstat(2) returns -1 and sets errno to ENOENT if the specified file
  does not exists or empty string.
  3) lstat(2) returns -1 and sets errno to EFAULT if pathname points
  outside user's accessible address space.
  4) lstat(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
  component is too long.
  5) lstat(2) returns -1 and sets errno to ENOTDIR if the directory
  component in pathname is not a directory.
  </description>
</test>
<test name="stat01">
  <description>
  Verify that, stat(2) succeeds to get the status of a file and fills the
  stat structure elements.
  </description>
</test>
<test name="stat02">
  <description>
  Verify that, stat(2) succeeds to get the status of a file and fills the
  stat structure elements though process doesn't have read access to the
  file.
  </description>
</test>
<test name="stat03">
  <description>
  Verify that,
  1) stat(2) returns -1 and sets errno to EACCES if search permission is
  denied on a component of the path prefix.
  2) stat(2) returns -1 and sets errno to ENOENT if the specified file
  does not exists or empty string.
  3) stat(2) returns -1 and sets errno to EFAULT if pathname points
  outside user's accessible address space.
  4) stat(2) returns -1 and sets errno to ENAMETOOLONG if the pathname
  component is too long.
  5) stat(2) returns -1 and sets errno to ENOTDIR if the directory
  component in pathname is not a directory.
  </description>
</test>
<test name="stat05">
  <description>
  Basic test for the stat05(2) system call. 
  </description>
</test>
<test name="statfs01">
  <description>
  Basic test for the statfs(2) system call. 
  </description>
</test>
<test name="statfs02">
  <description>
  Testcase to check that statfs(2) sets errno correctly.
  </description>
</test>
<test name="read01">
  <description>
  Basic test for the read(2) system call
  </description>
</test>
<test name="read02">
  <description>
  test 1: Does read return -1 if file descriptor is not valid, check for EBADF
  test 2: Check if read sets EISDIR, if the fd refers to a directory
  test 3: Check if read sets EFAULT, if buf is -1.
  </description>
</test>
<test name="read03">
  <description>
  Testcase to check that read() sets errno to EAGAIN
  </description>
</test>
<test name="read04">
  <description>
  Testcase to check if read returns the number of bytes read correctly.
  </description>
</test>
<test name="umask01">
  <description>
  Basic test for the umask(2) system call. 
  </description>
</test>
<test name="umask02">
  <description>
  Check that umask changes the mask, and that the previous
  value of the mask is returned correctly for each value.
  </description>
</test>
<test name="umask03">
  <description>
  Check that umask changes the mask, and that the previous
  value of the mask is returned correctly for each value.
  </description>
</test>
<test name="getgroups01">
  <description>
  Getgroups system call critical test 
  </description>
</test>
<test name="getgroups02">
  <description>
  Basic test for getgroups(2) 
  </description>
</test>
<test name="getgroups03">
  <description>
  Verify that, getgroups() system call gets the supplementary group IDs
  of the calling process.
  </description>
</test>
<test name="getgroups04">
  <description>
  Verify that,
  getgroups() fails with -1 and sets errno to EINVAL if the size
  argument value is -ve.
  </description>
</test>
<test name="gethostname01">
  <description>
  Basic test for gethostname(2)
  </description>
</test>
<test name="getpgid01">
  <description>
  Testcase to check the basic functionality of getpgid().
  </description>
</test>
<test name="getpgid02">
  <description>
  Testcase to check the basic functionality of getpgid().
  </description>
</test>
<test name="getpgrp01">
  <description>
  Basic test for getpgrp(2)
  </description>
</test>
<test name="getpriority01">
  <description>
  Verify that getpriority() succeeds get the scheduling priority of 
  the current process, process group or user.
  </description>
</test>
<test name="getpriority02">
  <description>
  Verify that,
  1) getpriority() sets errno to ESRCH  if no process was located
  was located for 'which' and 'who' arguments.
  2) getpriority() sets errno to EINVAL if 'which' argument was
  not one of PRIO_PROCESS, PRIO_PGRP, or PRIO_USER.
  </description>
</test>
<test name="getresgid01">
  <description>
  Verify that getresgid() will be successful to get the real, effective
  and saved user id of the calling process.
  </description>
</test>
<test name="getresgid02">
  <description>
  Verify that getresgid() will be successful to get the real, effective
  and saved user ids after calling process invokes setregid() to change
  the effective/saved gids to that of specified user.
  </description>
</test>
<test name="getresgid03">
  <description>
  Verify that getresgid() will be successful to get the real, effective
  and saved user ids after calling process invokes setresgid() to change
  the effective gid to that of specified user.
  </description>
</test>
<test name="getresuid01">
  <description>
  Verify that getresuid() will be successful to get the real, effective
  and saved user id of the calling process.
  </desciption>
</test>
<test name="getresuid02">
  <description>
  Verify that getresuid() will be successful to get the real, effective
  and saved user ids after calling process invokes setreuid() to change
  the effective/saved uids to that of specified user.
  </description>
</test>
<test name="getresuid03">
  <description>
  Verify that getresuid() will be successful to get the real, effective
  and saved user ids after calling process invokes setresuid() to change
  the effective uid to that of specified user.
  </description>
</test>
<test name="getsid01">
  <description>
  call getsid() and make sure it succeeds
  </description>
</test>
<test name="getsid02">
  <description>
  call getsid() with an invalid PID to produce a failure
  </description>
</test>
<test name="setfsgid01">
  <description>
  Testcase to check the basic functionality of setfsgid(2) system
  call.
  </description>
</test>
<test name="setfsuid01">
  <description>
  Testcase to test the basic functionality of the setfsuid(2) system
  call.
  </description>
</test>
<test name="setgid01">
  <description>
  Basic test for the setgid(2) system call. 
  </description>
</test>
<test name="setgid02">
  <description>
  Testcase to ensure that the setgid() system call sets errno to EPERM
  </description>
</test>
<test name="setgroups01">
  <description>
  Basic test for the setgroups(2) system call. 
  </description>
</test>
<test name="setgroups02">
  <description>
  Verify that,
  1. setgroups() fails with -1 and sets errno to EINVAL if the size
  argument value is > NGROUPS
  2. setgroups() fails with -1 and sets errno to EPERM if the
  calling process is not super-user.
  </description>
</test>
<test name="setgroups03">
  <description>
  Verify that, only root process can invoke setgroups() system call to
  set the supplementary group IDs of the process.
  </description>
</test>
<test name="setpgid01">
  <description>
  Basic test for setpgid(2) system call. 
  </description>
</test>
<test name="setpgid02">
  <description>
  Testcase to check that setpgid() sets errno correctly.
  </description>
</test>
<test name="setpgid03">
  <description>
  Test to check the error and trivial conditions in setpgid system call
  </description>
</test>
<test name="setpriority01">
  <description>
  set the priority for the test process lower.
  </description>
</test>
<test name="setpriority02">
  <description>
  test for an expected failure by trying to raise
  the priority for the test process while not having
  permissions to do so.
  </description>
</test>
<test name="setpriority03">
  <description>
  test for an expected failure by using an invalid
  PRIO value
  setpriority04  
  </description>
</test>
<test name="setpriority04">
  <description>
  test for an expected failure by using an invalid
  process id
  </description>
</test>
<test name="setpriority05">
  <description>
  test for an expected failure by trying to change
  a process with an ID that is different from the
  test process
  </description>
</test>
<test name="setregid01">
  <description>
  Basic test for the setregid(2) system call. 
  </description>
</test>
<test name="setregid02">
  <description>
  Test that setregid() fails and sets the proper errno values when a
  non-root user attempts to change the real or effective group id to a 
  value other than the current gid or the current effective gid. 
  </description>
</test>
<test name="setregid03">
  <description>
  Test setregid() when executed by a non-root user.
  </description>
</test>
<test name="setregid04">
  <description>
  Test setregid() when executed by root.
  </description>
</test>
<test name="setresuid01">
  <description>
  Test setresuid() when executed by root.
  </description>
</test>
<test name="setresuid02">
  <description>
  Test that a non-root user can change the real, effective and saved
  uid values through the setresuid system call.
  </description>
</test>
<test name="setresuid03">
  <description>
  Test that the setresuid system call sets the proper errno
  values when a non-root user attempts to change the real, effective or
  saved uid to a value other than one of the current uid, the current
  effective uid of the current saved uid.  Also verify that setresuid
  fails if an invalid uid value is given.
  </description>
</test>
<test name="setreuid01">
  <description>
  Basic test for the setreuid(2) system call. 
  </description>
</test>
<test name="setreuid02">
  <description>
  Test setreuid() when executed by root.
  </description>
</test>
<test name="setreuid03">
  <description>
  Test setreuid() when executed by an unprivileged user.
  </description>
</test>
<test name="setreuid04">
  <description>
  Test that root can change the real and effective uid to an
  unprivileged user.
  </description>
</test>
<test name="setreuid05">
  <description>
  Test the setreuid() feature, verifying the role of the saved-set-uid
  and setreuid's effect on it.
  </description>
</test>
<test name="setreuid06">
  <description>
  Test that EINVAL is set when setreuid is given an invalid user id.
  </description>
</test>
<test name="setrlimit01">
  <description>
  Testcase to check the basic functionality of the setrlimit system call.
  </description>
</test>
<test name="setrlimit02">
  <description>
  Testcase to test the different errnos set by setrlimit(2) system call.
  </description>
</test>
<test name="setrlimit03">
  <description>
  Test for EPERM when the super-user tries to increase RLIMIT_NOFILE
  beyond the system limit.
  </description>
</test>
<test name="setsid01">
  <description>
  Test to check the error and trivial conditions in setsid system call
  </description>
</test>
<test name="setuid01">
  <description>
  Basic test for the setuid(2) system call. 
  </description>
</test>
<test name="setuid02">
  <description>
  Basic test for the setuid(2) system call as root. 
  </description>
</test>
<test name="setuid03">
  <description>
  Test to check the error and trivial conditions in setuid
  </description>
</test>
<test name="fs_perms">
  <description>
  Regression test for Linux filesystem permissions.
  </description>
</test>
<test name="uname01">
  <description>
  Basic test for the uname(2) system call.  
  </description>
</test>
<test name="uname02">
  <description>
  Call uname() with an invalid address to produce a failure
  </description>
</test>
<test name="uname03">
  <description>
  Call uname() and make sure it succeeds
  </description>
</test>
<test name="sysctl01">
  <description>
  Testcase for testing the basic functionality of sysctl(2) system call.
  This testcase attempts to read the kernel parameters using
  sysctl({CTL_KERN, KERN_ }, ...) and compares it with the known
  values.
</test>
<test name="sysctl03">
  Testcase to check that sysctl(2) sets errno to EPERM correctly.
  </description>
</test>
<test name="sysctl04">
  <description>
  Testcase to check that sysctl(2) sets errno to ENOTDIR
  </description>
</test>
<test name="sysctl05">
  <description>
  Testcase to check that sysctl(2) sets errno to EFAULT
  </description>
</test>
<test name="time01">
  <description>
  Basic test for the time(2) system call. 
  </description>
</test>
<test name="time02">
  <description>
  Verify that time(2) returns the value of time in seconds since
  the Epoch and stores this value in the memory pointed to by the parameter.
  </description>
</test>
<test name="times01">
  <description>
  Basic test for the times(2) system call. 
  </description>
</test>
<test name="times02">
  <description>
  Testcase to test that times() sets errno correctly
  </description>
</test>
<test name="times03">
  <description>
  Testcase to check the basic functionality of the times() system call.
  </description>
</test>
<test name="utime01">
  <description>
  Verify that the system call utime() successfully sets the modification
  and access times of a file to the current time, if the times argument
  is null, and the user ID of the process is "root".
  </description>
</test>
<test name="utime02">
  <description>
  Verify that the system call utime() successfully sets the modification
  and access times of a file to the current time, under the following
  constraints,
  - The times argument is null.
  - The user ID of the process is not "root".
  - The file is owned by the user ID of the process.
  </description>
</test>
<test name="utime03">
  <description>
  Verify that the system call utime() successfully sets the modification
  and access times of a file to the current time, under the following
  constraints,
  - The times argument is null.
  - The user ID of the process is not "root".
  - The file is not owned by the user ID of the process.
  - The user ID of the process has write access to the file.
  </description>
</test>
<test name="utime04">
  <description>
  Verify that the system call utime() successfully sets the modification
  and access times of a file to the time specified by times argument, if
  the times argument is not null, and the user ID of the process is "root".
  </description>
</test>
<test name="utime05">
  <description>
  Verify that the system call utime() successfully sets the modification
  and access times of a file to the value specified by the times argument
  under the following constraints,
  - The times argument is not null,
  - The user ID of the process is not "root".
  - The file is owned by the user ID of the process.
  </description>
</test>
<test name="utime06">
  <description>
  1. Verify that the system call utime() fails to set the modification
  and access times of a file to the current time, under the following
  constraints,
  - The times argument is null.
  - The user ID of the process is not "root".
  - The file is not owned by the user ID of the process.
  - The user ID of the process does not have write access to the
  file.
  2. Verify that the system call utime() fails to set the modification
  and access times of a file if the specified file doesn't exist.
  </description>
</test>
<test name="settimeofday01">
  <description>
  Testcase to check the basic functionality of settimeofday().
  </description>
</test>
<test name="settimeofday02">
  <description>
  Testcase to check that settimeofday() sets errnos correctly.
  </description>
</test>
<test name="stime01">
  <description>
  Verify that the system call stime() successfully sets the system's idea
  of data and time if invoked by "root" user.
  </description>
</test>
<test name="stime02">
  <description>
  Verify that the system call stime() fails to set the system's idea
  of data and time if invoked by "non-root" user.
  </description>
</test>
<test name="gettimeofday01">
  <description>
  Testcase to check that gettimeofday(2) sets errno to EFAULT.
  </description>
</test>
<test name="alarm01">
  <description>
  Basic test for alarm(2). 
  </description>
</test>
<test name="alarm02">
  <description>
  Boundary Value Test for alarm(2).
  </description>
</test>
<test name="alarm03">
  <description>
  Alarm(2) cleared by a fork.
  </description>
</test>
<test name="alarm04">
  <description>
  Check that when an alarm request is made, the signal SIGALRM is received
  even after the process has done an exec().
  </description>
</test>
<test name="alarm05">
  <description>
  Check the functionality of the Alarm system call when the time input
  parameter is non zero.
  </description>
</test>
<test name="alarm06">
  <description>
  Check the functionality of the Alarm system call when the time input
  parameter is zero.
  </description>
</test>
<test name="alarm07">
  <description>
  Check the functionality of the alarm() when the time input
  parameter is non-zero and the process does a fork.
  </description>
</test>
<test name="getegid01">
  <description>
  Basic test for getegid(2) 
  </description>
</test>
<test name="geteuid01">
  <description>
  Basic test for geteuid(2) 
  </description>
</test>
<test name="getgid01">
  <description>
  Basic test for getgid(2) 
  </description>
</test>
<test name="getgid02">
  <description>
  Testcase to check the basic functionality of getgid().
  </description>
</test>
<test name="getgid03">
  <description>
  Testcase to check the basic functionality of getegid().
  </description>
</test>
<test name="getpid01">
  <description>
  Basic test for getpid(2) 
  </description>
</test>
<test name="getpid02">
  <description>
  Verify that getpid() system call gets the process ID of the of the
  calling process.
  </description>
</test>
<test name="getppid01">
  <description>
  Testcase to check the basic functionality of the getppid() syscall.
  </description>
</test>
<test name="getuid01">
  <description>
  Basic test for getuid(2)
  </description>
</test>
<test name="getuid02">
  <description>
  Testcase to check the basic functionality of the geteuid() system call.
  </description>
</test>
<test name="getuid03">
  <description>
  Testcase to check the basic functionality of the getuid() system call.
  </description>
</test>
<test name="nanosleep01">
  <description>
  Verify that nanosleep() will be successful to suspend the execution
  of a process for a specified time.
  </description>
</test>
<test name="nanosleep02">
  <description>
  Verify that nanosleep() will be successful to suspend the execution
  of a process, returns after the receipt of a signal and writes the
  remaining sleep time into the structure.
  </description>
</test>
<test name="nanosleep03">
  <description>
  Verify that nanosleep() will fail to suspend the execution
  of a process for a specified time if interrupted by a non-blocked signal.
  </description>
</test>
<test name="nanosleep04">
  <description>
  Verify that nanosleep() will fail to suspend the execution
  of a process if the specified pause time is invalid.
  </description>
</test>
